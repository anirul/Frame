#version 450

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

layout(set = 0, binding = 0, rgba16f) uniform writeonly image2D output_image;
layout(set = 0, binding = 1) uniform sampler2D raytrace_output;
layout(set = 0, binding = 2) uniform sampler2D albedo_texture;
layout(set = 0, binding = 3) uniform sampler2D normal_texture;
layout(set = 0, binding = 4) uniform sampler2D roughness_texture;
layout(set = 0, binding = 5) uniform sampler2D metallic_texture;
layout(set = 0, binding = 6) uniform sampler2D ao_texture;
layout(set = 0, binding = 7) uniform samplerCube skybox_env;

struct Vertex
{
    vec3 position;
    float pad0;
    vec3 normal;
    float pad1;
    vec2 uv;
    vec2 pad2;
};

struct Triangle
{
    Vertex v0;
    Vertex v1;
    Vertex v2;
};

layout(std430, set = 0, binding = 8) buffer TriangleBuffer
{
    vec4 tri_data[];
};

layout(set = 0, binding = 10) uniform UniformBlock
{
    mat4 projection;
    mat4 view;
    mat4 projection_inv;
    mat4 view_inv;
    mat4 model;
    mat4 model_inv;
    vec4 camera_position;
    vec4 light_dir;
    vec4 light_color;
    vec4 time_s;
} ubo;

struct BvhNode
{
    vec4 min;
    vec4 max;
    int left;
    int right;
    int first_triangle;
    int triangle_count;
};

layout(std430, set = 0, binding = 9) buffer BvhBuffer
{
    BvhNode nodes[];
};

int TriangleCount()
{
    return int(tri_data.length() / 9);
}

Triangle LoadTriangle(int tri_index)
{
    if (tri_index < 0 || tri_index >= TriangleCount())
    {
        Triangle empty_tri;
        empty_tri.v0.position = vec3(0.0);
        empty_tri.v0.normal = vec3(0.0);
        empty_tri.v0.uv = vec2(0.0);
        empty_tri.v1.position = vec3(0.0);
        empty_tri.v1.normal = vec3(0.0);
        empty_tri.v1.uv = vec2(0.0);
        empty_tri.v2.position = vec3(0.0);
        empty_tri.v2.normal = vec3(0.0);
        empty_tri.v2.uv = vec2(0.0);
        return empty_tri;
    }
    const int base = tri_index * 9;
    vec4 p0 = tri_data[base + 0];
    vec4 n0 = tri_data[base + 1];
    vec4 uv0 = tri_data[base + 2];
    vec4 p1 = tri_data[base + 3];
    vec4 n1 = tri_data[base + 4];
    vec4 uv1 = tri_data[base + 5];
    vec4 p2 = tri_data[base + 6];
    vec4 n2 = tri_data[base + 7];
    vec4 uv2 = tri_data[base + 8];

    Triangle tri;
    tri.v0.position = p0.xyz;
    tri.v0.normal = n0.xyz;
    tri.v0.uv = uv0.xy;
    tri.v1.position = p1.xyz;
    tri.v1.normal = n1.xyz;
    tri.v1.uv = uv1.xy;
    tri.v2.position = p2.xyz;
    tri.v2.normal = n2.xyz;
    tri.v2.uv = uv2.xy;
    return tri;
}

// ----------------------------------------------------------------------------
float DistributionGGX(vec3 N, vec3 H, float roughness)
{
    float a = roughness * roughness;
    float a2 = a * a;
    float NdotH = max(dot(N, H), 0.0);
    float NdotH2 = NdotH * NdotH;
    float denom = (NdotH2 * (a2 - 1.0) + 1.0);
    return a2 / (3.14159265 * denom * denom);
}

float GeometrySchlickGGX(float NdotV, float roughness)
{
    float r = roughness + 1.0;
    float k = (r * r) / 8.0;
    return NdotV / (NdotV * (1.0 - k) + k);
}

float GeometrySmith(vec3 N, vec3 V, vec3 L, float roughness)
{
    float NdotV = max(dot(N, V), 0.0);
    float NdotL = max(dot(N, L), 0.0);
    float ggx1 = GeometrySchlickGGX(NdotV, roughness);
    float ggx2 = GeometrySchlickGGX(NdotL, roughness);
    return ggx1 * ggx2;
}

vec3 fresnelSchlick(float cosTheta, vec3 F0)
{
    return F0 + (1.0 - F0) * pow(1.0 - cosTheta, 5.0);
}

bool rayTriangleIntersect(
    const vec3 ray_origin,
    const vec3 ray_direction,
    const Triangle triangle,
    out float out_t,
    out vec2 out_bary)
{
    const float EPSILON = 0.0000001;
    vec3 edge1 = triangle.v1.position - triangle.v0.position;
    vec3 edge2 = triangle.v2.position - triangle.v0.position;
    vec3 h = cross(ray_direction, edge2);
    float a = dot(edge1, h);
    if (a > -EPSILON && a < EPSILON)
        return false; // Ray is parallel to triangle.
    float f = 1.0 / a;
    vec3 s = ray_origin - triangle.v0.position;
    float u = f * dot(s, h);
    if (u < 0.0 || u > 1.0)
        return false;
    vec3 q = cross(s, edge1);
    float v = f * dot(ray_direction, q);
    if (v < 0.0 || u + v > 1.0)
        return false;
    float t = f * dot(edge2, q);
    if (t > EPSILON)
    {
        out_t = t;
        out_bary = vec2(u, v);
        return true;
    }
    return false;
}

bool rayAabbIntersect(
    const vec3 ray_origin, const vec3 inv_ray_dir, const BvhNode node)
{
    vec3 t0 = (node.min.xyz - ray_origin) * inv_ray_dir;
    vec3 t1 = (node.max.xyz - ray_origin) * inv_ray_dir;
    vec3 tmin = min(t0, t1);
    vec3 tmax = max(t0, t1);
    float t_enter = max(max(tmin.x, tmin.y), tmin.z);
    float t_exit = min(min(tmax.x, tmax.y), tmax.z);
    return t_exit >= max(t_enter, 0.0);
}

bool traverseBVH(
    const vec3 ray_origin,
    const vec3 ray_dir,
    out float out_t,
    out vec2 out_bary,
    out int out_tri)
{
    if (nodes.length() == 0)
    {
        return false;
    }
    vec3 inv_ray_dir = 1.0 / ray_dir;
    const int kMaxStack = 512;
    int stack[kMaxStack];
    int stack_ptr = 0;
    stack[stack_ptr++] = 0;
    out_t = 1e20;
    out_tri = -1;
    bool hit = false;
    while (stack_ptr > 0)
    {
        int node_index = stack[--stack_ptr];
        if (node_index < 0 || node_index >= nodes.length())
        {
            continue;
        }
        BvhNode node = nodes[node_index];
        if (!rayAabbIntersect(ray_origin, inv_ray_dir, node))
            continue;
        if (node.triangle_count > 0)
        {
            for (int i = 0; i < node.triangle_count; ++i)
            {
                int tri_index = node.first_triangle + i;
                float t;
                vec2 bary;
                if (rayTriangleIntersect(
                        ray_origin,
                        ray_dir,
                        LoadTriangle(tri_index),
                        t,
                        bary) &&
                    t < out_t)
                {
                    out_t = t;
                    out_bary = bary;
                    out_tri = tri_index;
                    hit = true;
                }
            }
        }
        else
        {
            if (node.left >= 0 && stack_ptr < kMaxStack)
                stack[stack_ptr++] = node.left;
            if (node.right >= 0 && stack_ptr < kMaxStack)
                stack[stack_ptr++] = node.right;
        }
    }
    return hit;
}

bool anyHitBVH(const vec3 ray_origin, const vec3 ray_dir)
{
    if (nodes.length() == 0)
    {
        return false;
    }
    vec3 inv_ray_dir = 1.0 / ray_dir;
    const int kMaxStack = 512;
    int stack[kMaxStack];
    int stack_ptr = 0;
    stack[stack_ptr++] = 0;
    while (stack_ptr > 0)
    {
        int node_index = stack[--stack_ptr];
        if (node_index < 0 || node_index >= nodes.length())
        {
            continue;
        }
        BvhNode node = nodes[node_index];
        if (!rayAabbIntersect(ray_origin, inv_ray_dir, node))
            continue;
        if (node.triangle_count > 0)
        {
            for (int i = 0; i < node.triangle_count; ++i)
            {
                int tri_index = node.first_triangle + i;
                float t;
                vec2 bary;
                if (rayTriangleIntersect(
                        ray_origin,
                        ray_dir,
                        LoadTriangle(tri_index),
                        t,
                        bary))
                    return true;
            }
        }
        else
        {
            if (node.left >= 0)
                stack[stack_ptr++] = node.left;
            if (node.right >= 0)
                stack[stack_ptr++] = node.right;
        }
    }
    return false;
}

void main()
{
    ivec2 pixel = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(output_image);
    if (pixel.x >= size.x || pixel.y >= size.y)
        return;

    if (TriangleCount() == 0)
    {
        imageStore(output_image, pixel, vec4(0.0, 0.0, 0.0, 1.0));
        return;
    }

    vec2 uv = (vec2(pixel) + vec2(0.5)) / vec2(size);
    uv.y = 1.0 - uv.y;
    const bool debug_hitmask = (ubo.time_s.w > 5.5 && ubo.time_s.w <= 6.5);
    const bool bruteforce_full = (ubo.time_s.w > 6.5);
    if (!debug_hitmask && !bruteforce_full && ubo.time_s.w > 3.5)
    {
        // Debug: show a UV gradient to validate the compute output path.
        imageStore(output_image, pixel, vec4(uv, 0.0, 1.0));
        return;
    }
    vec2 ndc = uv * 2.0 - 1.0;
    vec4 clip_pos = vec4(ndc, -1.0, 1.0);
    vec4 view_pos = ubo.projection_inv * clip_pos;
    // Match the OpenGL path: keep z at -1 and w at 0 after the inverse
    // projection to get a direction vector in view space, then transform to
    // world.
    view_pos = vec4(view_pos.xy, -1.0, 0.0);
    vec3 ray_dir_world = normalize((ubo.view_inv * view_pos).xyz);

    mat4 inv_model4 = ubo.model_inv;
    mat3 model_inv3 = mat3(inv_model4);
    float inv_det = abs(determinant(model_inv3));
    if (inv_det < 1e-8)
    {
        inv_model4 = inverse(ubo.model);
        model_inv3 = mat3(inv_model4);
    }
    mat3 normal_matrix = transpose(model_inv3);
    vec3 ray_origin = (inv_model4 * vec4(ubo.camera_position.xyz, 1.0)).xyz;
    vec3 ray_dir = normalize(model_inv3 * ray_dir_world);

    float closest_t;
    vec2 hit_bary;
    int tri_index;
    bool force_bruteforce =
        !debug_hitmask && !bruteforce_full &&
        (ubo.time_s.w > 1.5 && ubo.time_s.w <= 3.5);
    bool hit = false;
    if (!force_bruteforce && !bruteforce_full)
    {
        hit = traverseBVH(ray_origin, ray_dir, closest_t, hit_bary, tri_index);
    }
    if (!hit || bruteforce_full)
    {
        // Brute-force traversal to validate triangle packing when BVH
        // traversal fails (or when explicitly forced).
        float best_t = 1e20;
        vec2 best_bary = vec2(0.0);
        int best_tri = -1;
        const int tri_count = TriangleCount();
        for (int i = 0; i < tri_count; ++i)
        {
            float t;
            vec2 bary;
            if (rayTriangleIntersect(ray_origin, ray_dir, LoadTriangle(i), t, bary) &&
                t < best_t)
            {
                best_t = t;
                best_bary = bary;
                best_tri = i;
            }
        }
        if (best_tri >= 0)
        {
            hit = true;
            closest_t = best_t;
            hit_bary = best_bary;
            tri_index = best_tri;
        }
    }
    vec3 hit_normal_model = vec3(0.0);
    vec2 hit_uv = vec2(0.0);
    vec3 hit_tangent_model = vec3(0.0);
    vec3 hit_bitangent_model = vec3(0.0);
    if (hit)
    {
        Triangle tri = LoadTriangle(tri_index);
        float w = 1.0 - hit_bary.x - hit_bary.y;
        hit_normal_model = normalize(
            tri.v0.normal * w +
            tri.v1.normal * hit_bary.x +
            tri.v2.normal * hit_bary.y);
        hit_uv = tri.v0.uv * w +
                 tri.v1.uv * hit_bary.x +
                 tri.v2.uv * hit_bary.y;
        if (any(isnan(hit_uv)) || any(isinf(hit_uv)))
        {
            hit_uv = vec2(0.0);
        }
        if (any(isnan(hit_normal_model)) || any(isinf(hit_normal_model)))
        {
            hit_normal_model = vec3(0.0, 0.0, 1.0);
        }
        vec3 edge1 = tri.v1.position - tri.v0.position;
        vec3 edge2 = tri.v2.position - tri.v0.position;
        vec2 delta_uv1 = tri.v1.uv - tri.v0.uv;
        vec2 delta_uv2 = tri.v2.uv - tri.v0.uv;
        float det = delta_uv1.x * delta_uv2.y - delta_uv2.x * delta_uv1.y;
        if (abs(det) > 1e-8 && !isnan(det) && !isinf(det))
        {
            float f = 1.0 / det;
            hit_tangent_model =
                normalize(f * (delta_uv2.y * edge1 - delta_uv1.y * edge2));
            hit_bitangent_model =
                normalize(f * (-delta_uv2.x * edge1 + delta_uv1.x * edge2));
        }
    }

    vec4 final_color = vec4(0.0);
    if (hit)
    {
        vec3 N = normalize(normal_matrix * hit_normal_model);
        vec3 T = normalize(normal_matrix * hit_tangent_model);
        vec3 B = normalize(normal_matrix * hit_bitangent_model);
        if (length(T) < 0.001 ||
            length(B) < 0.001 ||
            any(isnan(T)) || any(isinf(T)) ||
            any(isnan(B)) || any(isinf(B)))
        {
            vec3 axis = abs(N.z) > 0.99 ? vec3(0.0, 1.0, 0.0) : vec3(0.0, 0.0, 1.0);
            T = normalize(cross(axis, N));
            B = normalize(cross(N, T));
        }
        bool tangent_ok =
            length(hit_tangent_model) > 0.001 &&
            length(hit_bitangent_model) > 0.001;
        vec3 hit_normal = N;
        if (tangent_ok)
        {
            vec3 normal_map = texture(normal_texture, hit_uv).xyz * 2.0 - 1.0;
            hit_normal = normalize(mat3(T, B, N) * normal_map);
        }
        if (length(hit_normal) < 0.001 ||
            any(isnan(hit_normal)) ||
            any(isinf(hit_normal)))
        {
            hit_normal = N;
        }
        if (debug_hitmask)
        {
            // Debug: show which inputs go NaN/inf.
            vec3 debug = vec3(0.0);
            if (any(isnan(hit_uv)) || any(isinf(hit_uv)))
            {
                debug.r = 1.0;
            }
            if (any(isnan(N)) || any(isinf(N)) ||
                any(isnan(hit_normal_model)) || any(isinf(hit_normal_model)))
            {
                debug.g = 1.0;
            }
            if (any(isnan(T)) || any(isinf(T)) ||
                any(isnan(B)) || any(isinf(B)) ||
                any(isnan(hit_tangent_model)) || any(isinf(hit_tangent_model)) ||
                any(isnan(hit_bitangent_model)) || any(isinf(hit_bitangent_model)))
            {
                debug.b = 1.0;
            }
            if (all(equal(debug, vec3(0.0))))
            {
                debug = vec3(0.2, 0.2, 0.2);
            }
            imageStore(output_image, pixel, vec4(debug, 1.0));
            return;
        }
        vec3 hit_pos_model = ray_origin + closest_t * ray_dir;
        vec3 light_dir_world = length(ubo.light_dir.xyz) > 0.0
            ? ubo.light_dir.xyz
            : vec3(1.0, -1.0, 1.0);
        vec3 light_col = length(ubo.light_color.xyz) > 0.0
            ? ubo.light_color.xyz
            : vec3(1.0);
        vec3 shadow_dir_model = normalize(model_inv3 * -light_dir_world);
        vec3 shadow_origin = hit_pos_model + hit_normal_model * 0.0015;
        bool in_shadow = anyHitBVH(shadow_origin, shadow_dir_model);

        float shadow_factor = in_shadow ? 0.3 : 1.0;
        vec3 albedo = texture(albedo_texture, hit_uv).rgb;
        float roughness = texture(roughness_texture, hit_uv).r;
        float metallic = texture(metallic_texture, hit_uv).r;
        float ao = texture(ao_texture, hit_uv).r;
        vec3 hit_pos_world = (ubo.model * vec4(hit_pos_model, 1.0)).xyz;
        vec3 V = normalize(ubo.camera_position.xyz - hit_pos_world);
        vec3 L = normalize(-light_dir_world);
        vec3 H = normalize(V + L);
        vec3 F0 = mix(vec3(0.04), albedo, metallic);
        vec3 F = fresnelSchlick(max(dot(H, V), 0.0), F0);
        float D = DistributionGGX(hit_normal, H, roughness);
        float G = GeometrySmith(hit_normal, V, L, roughness);
        vec3 numerator = D * G * F;
        float denominator = 4.0 *
            max(dot(hit_normal, V), 0.0) *
            max(dot(hit_normal, L), 0.0) + 0.001;
        vec3 specular = numerator / denominator;
        vec3 kS = F;
        vec3 kD = (1.0 - kS) * (1.0 - metallic);
        vec3 diffuse = kD * albedo / 3.14159265;
        float NdotL = max(dot(hit_normal, L), 0.0);
        float NdotV = max(dot(hit_normal, V), 0.0);
        vec3 reflection_dir_world = normalize(reflect(-ray_dir_world, hit_normal));
        vec3 env_lookup_dir = vec3(
            reflection_dir_world.x, -reflection_dir_world.y, reflection_dir_world.z);
        vec3 env_diffuse_dir = vec3(N.x, -N.y, N.z);
        int env_levels = textureQueryLevels(skybox_env);
        float max_env_lod = env_levels > 0 ? float(env_levels - 1) : 0.0;
        float specular_lod = clamp(roughness * max_env_lod, 0.0, max_env_lod);
        vec3 env_color = textureLod(skybox_env, env_lookup_dir, specular_lod).rgb;
        vec3 env_diffuse = textureLod(skybox_env, env_diffuse_dir, max_env_lod).rgb;
        vec3 reflection_sample = env_color;
        bool should_trace_reflection = (NdotV > 0.2) && (roughness < 0.65);
        if (should_trace_reflection)
        {
            vec3 reflection_origin_model = hit_pos_model + hit_normal_model * 0.0015;
            vec3 reflection_dir_model = normalize(model_inv3 * reflection_dir_world);
            float reflection_t;
            vec2 reflection_bary;
            int reflection_tri;
            if (traverseBVH(
                    reflection_origin_model,
                    reflection_dir_model,
                    reflection_t,
                    reflection_bary,
                    reflection_tri))
            {
            Triangle reflection_triangle = LoadTriangle(reflection_tri);
            float reflection_w = 1.0 - reflection_bary.x - reflection_bary.y;
            vec2 reflection_uv =
                reflection_triangle.v0.uv * reflection_w +
                reflection_triangle.v1.uv * reflection_bary.x +
                reflection_triangle.v2.uv * reflection_bary.y;
                reflection_sample = texture(albedo_texture, reflection_uv).rgb;
            }
            reflection_sample = mix(env_color, reflection_sample, 0.7);
        }
        vec3 ambient = kD * albedo * 0.05 * ao +
                       kD * albedo / 3.14159265 * env_diffuse * ao;
        vec3 env_specular = specular * reflection_sample * ao *
            (in_shadow ? 0.0 : 1.0);
        env_specular = clamp(env_specular, 0.0, 10.0);
        vec3 Lo = diffuse * light_col * NdotL * shadow_factor +
                  specular * light_col * NdotL * (in_shadow ? 0.0 : 1.0) +
                  env_specular;
        final_color = vec4(ambient + Lo, 1.0);
    }
    else
    {
        vec3 env_dir = vec3(ray_dir_world.x, -ray_dir_world.y, ray_dir_world.z);
        int env_levels = textureQueryLevels(skybox_env);
        float max_env_lod = env_levels > 0 ? float(env_levels - 1) : 0.0;
        vec3 env_color = textureLod(skybox_env, env_dir, max_env_lod).rgb;
        final_color = vec4(env_color, 1.0);
    }

    if (any(isnan(final_color)) || any(isinf(final_color)))
    {
        final_color = vec4(1.0, 0.0, 1.0, 1.0);
    }
    imageStore(output_image, pixel, final_color);
}
