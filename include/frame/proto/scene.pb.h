// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: scene.proto
// Protobuf C++ Version: 5.29.3

#ifndef scene_2eproto_2epb_2eh
#define scene_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5029003
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/message_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "pixel.pb.h"
#include "math.pb.h"
#include "plugin.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_scene_2eproto

namespace google {
namespace protobuf {
namespace internal {
template <typename T>
::absl::string_view GetAnyMessageName();
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_scene_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_scene_2eproto;
namespace frame {
namespace proto {
class NodeCamera;
struct NodeCameraDefaultTypeInternal;
extern NodeCameraDefaultTypeInternal _NodeCamera_default_instance_;
class NodeLight;
struct NodeLightDefaultTypeInternal;
extern NodeLightDefaultTypeInternal _NodeLight_default_instance_;
class NodeMatrix;
struct NodeMatrixDefaultTypeInternal;
extern NodeMatrixDefaultTypeInternal _NodeMatrix_default_instance_;
class NodeStaticMesh;
struct NodeStaticMeshDefaultTypeInternal;
extern NodeStaticMeshDefaultTypeInternal _NodeStaticMesh_default_instance_;
class SceneTree;
struct SceneTreeDefaultTypeInternal;
extern SceneTreeDefaultTypeInternal _SceneTree_default_instance_;
}  // namespace proto
}  // namespace frame
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace frame {
namespace proto {
enum NodeMatrix_MatrixTypeEnum : int {
  NodeMatrix_MatrixTypeEnum_STATIC_MATRIX = 0,
  NodeMatrix_MatrixTypeEnum_ROTATION_MATRIX = 1,
  NodeMatrix_MatrixTypeEnum_NodeMatrix_MatrixTypeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeMatrix_MatrixTypeEnum_NodeMatrix_MatrixTypeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeMatrix_MatrixTypeEnum_IsValid(int value);
extern const uint32_t NodeMatrix_MatrixTypeEnum_internal_data_[];
constexpr NodeMatrix_MatrixTypeEnum NodeMatrix_MatrixTypeEnum_MatrixTypeEnum_MIN = static_cast<NodeMatrix_MatrixTypeEnum>(0);
constexpr NodeMatrix_MatrixTypeEnum NodeMatrix_MatrixTypeEnum_MatrixTypeEnum_MAX = static_cast<NodeMatrix_MatrixTypeEnum>(1);
constexpr int NodeMatrix_MatrixTypeEnum_MatrixTypeEnum_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
NodeMatrix_MatrixTypeEnum_descriptor();
template <typename T>
const std::string& NodeMatrix_MatrixTypeEnum_Name(T value) {
  static_assert(std::is_same<T, NodeMatrix_MatrixTypeEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MatrixTypeEnum_Name().");
  return NodeMatrix_MatrixTypeEnum_Name(static_cast<NodeMatrix_MatrixTypeEnum>(value));
}
template <>
inline const std::string& NodeMatrix_MatrixTypeEnum_Name(NodeMatrix_MatrixTypeEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeMatrix_MatrixTypeEnum_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool NodeMatrix_MatrixTypeEnum_Parse(absl::string_view name, NodeMatrix_MatrixTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeMatrix_MatrixTypeEnum>(
      NodeMatrix_MatrixTypeEnum_descriptor(), name, value);
}
enum NodeStaticMesh_RenderPrimitiveEnum : int {
  NodeStaticMesh_RenderPrimitiveEnum_TRIANGLE_PRIMITIVE = 0,
  NodeStaticMesh_RenderPrimitiveEnum_POINT_PRIMITIVE = 1,
  NodeStaticMesh_RenderPrimitiveEnum_LINE_PRIMITIVE = 2,
  NodeStaticMesh_RenderPrimitiveEnum_NodeStaticMesh_RenderPrimitiveEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeStaticMesh_RenderPrimitiveEnum_NodeStaticMesh_RenderPrimitiveEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeStaticMesh_RenderPrimitiveEnum_IsValid(int value);
extern const uint32_t NodeStaticMesh_RenderPrimitiveEnum_internal_data_[];
constexpr NodeStaticMesh_RenderPrimitiveEnum NodeStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MIN = static_cast<NodeStaticMesh_RenderPrimitiveEnum>(0);
constexpr NodeStaticMesh_RenderPrimitiveEnum NodeStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MAX = static_cast<NodeStaticMesh_RenderPrimitiveEnum>(2);
constexpr int NodeStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
NodeStaticMesh_RenderPrimitiveEnum_descriptor();
template <typename T>
const std::string& NodeStaticMesh_RenderPrimitiveEnum_Name(T value) {
  static_assert(std::is_same<T, NodeStaticMesh_RenderPrimitiveEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RenderPrimitiveEnum_Name().");
  return NodeStaticMesh_RenderPrimitiveEnum_Name(static_cast<NodeStaticMesh_RenderPrimitiveEnum>(value));
}
template <>
inline const std::string& NodeStaticMesh_RenderPrimitiveEnum_Name(NodeStaticMesh_RenderPrimitiveEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeStaticMesh_RenderPrimitiveEnum_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool NodeStaticMesh_RenderPrimitiveEnum_Parse(absl::string_view name, NodeStaticMesh_RenderPrimitiveEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeStaticMesh_RenderPrimitiveEnum>(
      NodeStaticMesh_RenderPrimitiveEnum_descriptor(), name, value);
}
enum NodeStaticMesh_MeshEnum : int {
  NodeStaticMesh_MeshEnum_INVALID = 0,
  NodeStaticMesh_MeshEnum_CUBE = 1,
  NodeStaticMesh_MeshEnum_QUAD = 2,
  NodeStaticMesh_MeshEnum_NodeStaticMesh_MeshEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeStaticMesh_MeshEnum_NodeStaticMesh_MeshEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeStaticMesh_MeshEnum_IsValid(int value);
extern const uint32_t NodeStaticMesh_MeshEnum_internal_data_[];
constexpr NodeStaticMesh_MeshEnum NodeStaticMesh_MeshEnum_MeshEnum_MIN = static_cast<NodeStaticMesh_MeshEnum>(0);
constexpr NodeStaticMesh_MeshEnum NodeStaticMesh_MeshEnum_MeshEnum_MAX = static_cast<NodeStaticMesh_MeshEnum>(2);
constexpr int NodeStaticMesh_MeshEnum_MeshEnum_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
NodeStaticMesh_MeshEnum_descriptor();
template <typename T>
const std::string& NodeStaticMesh_MeshEnum_Name(T value) {
  static_assert(std::is_same<T, NodeStaticMesh_MeshEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MeshEnum_Name().");
  return NodeStaticMesh_MeshEnum_Name(static_cast<NodeStaticMesh_MeshEnum>(value));
}
template <>
inline const std::string& NodeStaticMesh_MeshEnum_Name(NodeStaticMesh_MeshEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeStaticMesh_MeshEnum_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool NodeStaticMesh_MeshEnum_Parse(absl::string_view name, NodeStaticMesh_MeshEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeStaticMesh_MeshEnum>(
      NodeStaticMesh_MeshEnum_descriptor(), name, value);
}
enum NodeStaticMesh_RenderTimeEnum : int {
  NodeStaticMesh_RenderTimeEnum_SCENE_RENDER_TIME = 0,
  NodeStaticMesh_RenderTimeEnum_PRE_RENDER_TIME = 1,
  NodeStaticMesh_RenderTimeEnum_POST_PROCESS_TIME = 2,
  NodeStaticMesh_RenderTimeEnum_SKYBOX_RENDER_TIME = 3,
  NodeStaticMesh_RenderTimeEnum_SHADOW_RENDER_TIME = 4,
  NodeStaticMesh_RenderTimeEnum_NodeStaticMesh_RenderTimeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeStaticMesh_RenderTimeEnum_NodeStaticMesh_RenderTimeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeStaticMesh_RenderTimeEnum_IsValid(int value);
extern const uint32_t NodeStaticMesh_RenderTimeEnum_internal_data_[];
constexpr NodeStaticMesh_RenderTimeEnum NodeStaticMesh_RenderTimeEnum_RenderTimeEnum_MIN = static_cast<NodeStaticMesh_RenderTimeEnum>(0);
constexpr NodeStaticMesh_RenderTimeEnum NodeStaticMesh_RenderTimeEnum_RenderTimeEnum_MAX = static_cast<NodeStaticMesh_RenderTimeEnum>(4);
constexpr int NodeStaticMesh_RenderTimeEnum_RenderTimeEnum_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
NodeStaticMesh_RenderTimeEnum_descriptor();
template <typename T>
const std::string& NodeStaticMesh_RenderTimeEnum_Name(T value) {
  static_assert(std::is_same<T, NodeStaticMesh_RenderTimeEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RenderTimeEnum_Name().");
  return NodeStaticMesh_RenderTimeEnum_Name(static_cast<NodeStaticMesh_RenderTimeEnum>(value));
}
template <>
inline const std::string& NodeStaticMesh_RenderTimeEnum_Name(NodeStaticMesh_RenderTimeEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeStaticMesh_RenderTimeEnum_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool NodeStaticMesh_RenderTimeEnum_Parse(absl::string_view name, NodeStaticMesh_RenderTimeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeStaticMesh_RenderTimeEnum>(
      NodeStaticMesh_RenderTimeEnum_descriptor(), name, value);
}
enum NodeStaticMesh_ShadowEffectEnum : int {
  NodeStaticMesh_ShadowEffectEnum_OPAQUE_SHADOW_EFFECT = 0,
  NodeStaticMesh_ShadowEffectEnum_TRANSPARENT_SHADOW_EFFECT = 1,
  NodeStaticMesh_ShadowEffectEnum_NodeStaticMesh_ShadowEffectEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeStaticMesh_ShadowEffectEnum_NodeStaticMesh_ShadowEffectEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeStaticMesh_ShadowEffectEnum_IsValid(int value);
extern const uint32_t NodeStaticMesh_ShadowEffectEnum_internal_data_[];
constexpr NodeStaticMesh_ShadowEffectEnum NodeStaticMesh_ShadowEffectEnum_ShadowEffectEnum_MIN = static_cast<NodeStaticMesh_ShadowEffectEnum>(0);
constexpr NodeStaticMesh_ShadowEffectEnum NodeStaticMesh_ShadowEffectEnum_ShadowEffectEnum_MAX = static_cast<NodeStaticMesh_ShadowEffectEnum>(1);
constexpr int NodeStaticMesh_ShadowEffectEnum_ShadowEffectEnum_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
NodeStaticMesh_ShadowEffectEnum_descriptor();
template <typename T>
const std::string& NodeStaticMesh_ShadowEffectEnum_Name(T value) {
  static_assert(std::is_same<T, NodeStaticMesh_ShadowEffectEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ShadowEffectEnum_Name().");
  return NodeStaticMesh_ShadowEffectEnum_Name(static_cast<NodeStaticMesh_ShadowEffectEnum>(value));
}
template <>
inline const std::string& NodeStaticMesh_ShadowEffectEnum_Name(NodeStaticMesh_ShadowEffectEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeStaticMesh_ShadowEffectEnum_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool NodeStaticMesh_ShadowEffectEnum_Parse(absl::string_view name, NodeStaticMesh_ShadowEffectEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeStaticMesh_ShadowEffectEnum>(
      NodeStaticMesh_ShadowEffectEnum_descriptor(), name, value);
}
enum NodeLight_LightTypeEnum : int {
  NodeLight_LightTypeEnum_INVALID_LIGHT = 0,
  NodeLight_LightTypeEnum_AMBIENT_LIGHT = 1,
  NodeLight_LightTypeEnum_POINT_LIGHT = 2,
  NodeLight_LightTypeEnum_DIRECTIONAL_LIGHT = 3,
  NodeLight_LightTypeEnum_SPOT_LIGHT = 4,
  NodeLight_LightTypeEnum_NodeLight_LightTypeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeLight_LightTypeEnum_NodeLight_LightTypeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeLight_LightTypeEnum_IsValid(int value);
extern const uint32_t NodeLight_LightTypeEnum_internal_data_[];
constexpr NodeLight_LightTypeEnum NodeLight_LightTypeEnum_LightTypeEnum_MIN = static_cast<NodeLight_LightTypeEnum>(0);
constexpr NodeLight_LightTypeEnum NodeLight_LightTypeEnum_LightTypeEnum_MAX = static_cast<NodeLight_LightTypeEnum>(4);
constexpr int NodeLight_LightTypeEnum_LightTypeEnum_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
NodeLight_LightTypeEnum_descriptor();
template <typename T>
const std::string& NodeLight_LightTypeEnum_Name(T value) {
  static_assert(std::is_same<T, NodeLight_LightTypeEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LightTypeEnum_Name().");
  return NodeLight_LightTypeEnum_Name(static_cast<NodeLight_LightTypeEnum>(value));
}
template <>
inline const std::string& NodeLight_LightTypeEnum_Name(NodeLight_LightTypeEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeLight_LightTypeEnum_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool NodeLight_LightTypeEnum_Parse(absl::string_view name, NodeLight_LightTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeLight_LightTypeEnum>(
      NodeLight_LightTypeEnum_descriptor(), name, value);
}
enum NodeLight_ShadowTypeEnum : int {
  NodeLight_ShadowTypeEnum_NO_SHADOW = 0,
  NodeLight_ShadowTypeEnum_HARD_SHADOW = 1,
  NodeLight_ShadowTypeEnum_SOFT_SHADOW = 2,
  NodeLight_ShadowTypeEnum_NodeLight_ShadowTypeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  NodeLight_ShadowTypeEnum_NodeLight_ShadowTypeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool NodeLight_ShadowTypeEnum_IsValid(int value);
extern const uint32_t NodeLight_ShadowTypeEnum_internal_data_[];
constexpr NodeLight_ShadowTypeEnum NodeLight_ShadowTypeEnum_ShadowTypeEnum_MIN = static_cast<NodeLight_ShadowTypeEnum>(0);
constexpr NodeLight_ShadowTypeEnum NodeLight_ShadowTypeEnum_ShadowTypeEnum_MAX = static_cast<NodeLight_ShadowTypeEnum>(2);
constexpr int NodeLight_ShadowTypeEnum_ShadowTypeEnum_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
NodeLight_ShadowTypeEnum_descriptor();
template <typename T>
const std::string& NodeLight_ShadowTypeEnum_Name(T value) {
  static_assert(std::is_same<T, NodeLight_ShadowTypeEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ShadowTypeEnum_Name().");
  return NodeLight_ShadowTypeEnum_Name(static_cast<NodeLight_ShadowTypeEnum>(value));
}
template <>
inline const std::string& NodeLight_ShadowTypeEnum_Name(NodeLight_ShadowTypeEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<NodeLight_ShadowTypeEnum_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool NodeLight_ShadowTypeEnum_Parse(absl::string_view name, NodeLight_ShadowTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<NodeLight_ShadowTypeEnum>(
      NodeLight_ShadowTypeEnum_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class NodeMatrix final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:frame.proto.NodeMatrix) */ {
 public:
  inline NodeMatrix() : NodeMatrix(nullptr) {}
  ~NodeMatrix() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeMatrix* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeMatrix));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeMatrix(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeMatrix(const NodeMatrix& from) : NodeMatrix(nullptr, from) {}
  inline NodeMatrix(NodeMatrix&& from) noexcept
      : NodeMatrix(nullptr, std::move(from)) {}
  inline NodeMatrix& operator=(const NodeMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeMatrix& operator=(NodeMatrix&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeMatrix& default_instance() {
    return *internal_default_instance();
  }
  enum MatrixOneofCase {
    kMatrix = 3,
    kQuaternion = 4,
    MATRIX_ONEOF_NOT_SET = 0,
  };
  static inline const NodeMatrix* internal_default_instance() {
    return reinterpret_cast<const NodeMatrix*>(
        &_NodeMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 0;
  friend void swap(NodeMatrix& a, NodeMatrix& b) { a.Swap(&b); }
  inline void Swap(NodeMatrix* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeMatrix* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeMatrix* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeMatrix>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeMatrix& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeMatrix& from) { NodeMatrix::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeMatrix* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "frame.proto.NodeMatrix"; }

 protected:
  explicit NodeMatrix(::google::protobuf::Arena* arena);
  NodeMatrix(::google::protobuf::Arena* arena, const NodeMatrix& from);
  NodeMatrix(::google::protobuf::Arena* arena, NodeMatrix&& from) noexcept
      : NodeMatrix(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using MatrixTypeEnum = NodeMatrix_MatrixTypeEnum;
  static constexpr MatrixTypeEnum STATIC_MATRIX = NodeMatrix_MatrixTypeEnum_STATIC_MATRIX;
  static constexpr MatrixTypeEnum ROTATION_MATRIX = NodeMatrix_MatrixTypeEnum_ROTATION_MATRIX;
  static inline bool MatrixTypeEnum_IsValid(int value) {
    return NodeMatrix_MatrixTypeEnum_IsValid(value);
  }
  static constexpr MatrixTypeEnum MatrixTypeEnum_MIN = NodeMatrix_MatrixTypeEnum_MatrixTypeEnum_MIN;
  static constexpr MatrixTypeEnum MatrixTypeEnum_MAX = NodeMatrix_MatrixTypeEnum_MatrixTypeEnum_MAX;
  static constexpr int MatrixTypeEnum_ARRAYSIZE = NodeMatrix_MatrixTypeEnum_MatrixTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MatrixTypeEnum_descriptor() {
    return NodeMatrix_MatrixTypeEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& MatrixTypeEnum_Name(T value) {
    return NodeMatrix_MatrixTypeEnum_Name(value);
  }
  static inline bool MatrixTypeEnum_Parse(absl::string_view name, MatrixTypeEnum* value) {
    return NodeMatrix_MatrixTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kMatrixTypeEnumFieldNumber = 5,
    kMatrixFieldNumber = 3,
    kQuaternionFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string parent = 2;
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // .frame.proto.NodeMatrix.MatrixTypeEnum matrix_type_enum = 5;
  void clear_matrix_type_enum() ;
  ::frame::proto::NodeMatrix_MatrixTypeEnum matrix_type_enum() const;
  void set_matrix_type_enum(::frame::proto::NodeMatrix_MatrixTypeEnum value);

  private:
  ::frame::proto::NodeMatrix_MatrixTypeEnum _internal_matrix_type_enum() const;
  void _internal_set_matrix_type_enum(::frame::proto::NodeMatrix_MatrixTypeEnum value);

  public:
  // .frame.proto.UniformMatrix4 matrix = 3;
  bool has_matrix() const;
  private:
  bool _internal_has_matrix() const;

  public:
  void clear_matrix() ;
  const ::frame::proto::UniformMatrix4& matrix() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformMatrix4* release_matrix();
  ::frame::proto::UniformMatrix4* mutable_matrix();
  void set_allocated_matrix(::frame::proto::UniformMatrix4* value);
  void unsafe_arena_set_allocated_matrix(::frame::proto::UniformMatrix4* value);
  ::frame::proto::UniformMatrix4* unsafe_arena_release_matrix();

  private:
  const ::frame::proto::UniformMatrix4& _internal_matrix() const;
  ::frame::proto::UniformMatrix4* _internal_mutable_matrix();

  public:
  // .frame.proto.UniformVector4 quaternion = 4;
  bool has_quaternion() const;
  private:
  bool _internal_has_quaternion() const;

  public:
  void clear_quaternion() ;
  const ::frame::proto::UniformVector4& quaternion() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector4* release_quaternion();
  ::frame::proto::UniformVector4* mutable_quaternion();
  void set_allocated_quaternion(::frame::proto::UniformVector4* value);
  void unsafe_arena_set_allocated_quaternion(::frame::proto::UniformVector4* value);
  ::frame::proto::UniformVector4* unsafe_arena_release_quaternion();

  private:
  const ::frame::proto::UniformVector4& _internal_quaternion() const;
  ::frame::proto::UniformVector4* _internal_mutable_quaternion();

  public:
  void clear_matrix_oneof();
  MatrixOneofCase matrix_oneof_case() const;
  // @@protoc_insertion_point(class_scope:frame.proto.NodeMatrix)
 private:
  class _Internal;
  void set_has_matrix();
  void set_has_quaternion();
  inline bool has_matrix_oneof() const;
  inline void clear_has_matrix_oneof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 5, 2,
      41, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeMatrix& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    int matrix_type_enum_;
    union MatrixOneofUnion {
      constexpr MatrixOneofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::frame::proto::UniformMatrix4* matrix_;
      ::frame::proto::UniformVector4* quaternion_;
    } matrix_oneof_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class NodeLight final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:frame.proto.NodeLight) */ {
 public:
  inline NodeLight() : NodeLight(nullptr) {}
  ~NodeLight() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeLight* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeLight));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeLight(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeLight(const NodeLight& from) : NodeLight(nullptr, from) {}
  inline NodeLight(NodeLight&& from) noexcept
      : NodeLight(nullptr, std::move(from)) {}
  inline NodeLight& operator=(const NodeLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeLight& operator=(NodeLight&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeLight& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeLight* internal_default_instance() {
    return reinterpret_cast<const NodeLight*>(
        &_NodeLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 3;
  friend void swap(NodeLight& a, NodeLight& b) { a.Swap(&b); }
  inline void Swap(NodeLight* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeLight* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeLight* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeLight>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeLight& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeLight& from) { NodeLight::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeLight* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "frame.proto.NodeLight"; }

 protected:
  explicit NodeLight(::google::protobuf::Arena* arena);
  NodeLight(::google::protobuf::Arena* arena, const NodeLight& from);
  NodeLight(::google::protobuf::Arena* arena, NodeLight&& from) noexcept
      : NodeLight(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using LightTypeEnum = NodeLight_LightTypeEnum;
  static constexpr LightTypeEnum INVALID_LIGHT = NodeLight_LightTypeEnum_INVALID_LIGHT;
  static constexpr LightTypeEnum AMBIENT_LIGHT = NodeLight_LightTypeEnum_AMBIENT_LIGHT;
  static constexpr LightTypeEnum POINT_LIGHT = NodeLight_LightTypeEnum_POINT_LIGHT;
  static constexpr LightTypeEnum DIRECTIONAL_LIGHT = NodeLight_LightTypeEnum_DIRECTIONAL_LIGHT;
  static constexpr LightTypeEnum SPOT_LIGHT = NodeLight_LightTypeEnum_SPOT_LIGHT;
  static inline bool LightTypeEnum_IsValid(int value) {
    return NodeLight_LightTypeEnum_IsValid(value);
  }
  static constexpr LightTypeEnum LightTypeEnum_MIN = NodeLight_LightTypeEnum_LightTypeEnum_MIN;
  static constexpr LightTypeEnum LightTypeEnum_MAX = NodeLight_LightTypeEnum_LightTypeEnum_MAX;
  static constexpr int LightTypeEnum_ARRAYSIZE = NodeLight_LightTypeEnum_LightTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LightTypeEnum_descriptor() {
    return NodeLight_LightTypeEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& LightTypeEnum_Name(T value) {
    return NodeLight_LightTypeEnum_Name(value);
  }
  static inline bool LightTypeEnum_Parse(absl::string_view name, LightTypeEnum* value) {
    return NodeLight_LightTypeEnum_Parse(name, value);
  }
  using ShadowTypeEnum = NodeLight_ShadowTypeEnum;
  static constexpr ShadowTypeEnum NO_SHADOW = NodeLight_ShadowTypeEnum_NO_SHADOW;
  static constexpr ShadowTypeEnum HARD_SHADOW = NodeLight_ShadowTypeEnum_HARD_SHADOW;
  static constexpr ShadowTypeEnum SOFT_SHADOW = NodeLight_ShadowTypeEnum_SOFT_SHADOW;
  static inline bool ShadowTypeEnum_IsValid(int value) {
    return NodeLight_ShadowTypeEnum_IsValid(value);
  }
  static constexpr ShadowTypeEnum ShadowTypeEnum_MIN = NodeLight_ShadowTypeEnum_ShadowTypeEnum_MIN;
  static constexpr ShadowTypeEnum ShadowTypeEnum_MAX = NodeLight_ShadowTypeEnum_ShadowTypeEnum_MAX;
  static constexpr int ShadowTypeEnum_ARRAYSIZE = NodeLight_ShadowTypeEnum_ShadowTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ShadowTypeEnum_descriptor() {
    return NodeLight_ShadowTypeEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& ShadowTypeEnum_Name(T value) {
    return NodeLight_ShadowTypeEnum_Name(value);
  }
  static inline bool ShadowTypeEnum_Parse(absl::string_view name, ShadowTypeEnum* value) {
    return NodeLight_ShadowTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kShadowTextureFieldNumber = 10,
    kPositionFieldNumber = 4,
    kDirectionFieldNumber = 5,
    kColorFieldNumber = 8,
    kLightTypeFieldNumber = 3,
    kDotInnerLimitFieldNumber = 6,
    kDotOuterLimitFieldNumber = 7,
    kShadowTypeFieldNumber = 9,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string parent = 2;
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // string shadow_texture = 10;
  void clear_shadow_texture() ;
  const std::string& shadow_texture() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shadow_texture(Arg_&& arg, Args_... args);
  std::string* mutable_shadow_texture();
  PROTOBUF_NODISCARD std::string* release_shadow_texture();
  void set_allocated_shadow_texture(std::string* value);

  private:
  const std::string& _internal_shadow_texture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shadow_texture(
      const std::string& value);
  std::string* _internal_mutable_shadow_texture();

  public:
  // .frame.proto.UniformVector3 position = 4;
  bool has_position() const;
  void clear_position() ;
  const ::frame::proto::UniformVector3& position() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_position();
  ::frame::proto::UniformVector3* mutable_position();
  void set_allocated_position(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_position(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_position();

  private:
  const ::frame::proto::UniformVector3& _internal_position() const;
  ::frame::proto::UniformVector3* _internal_mutable_position();

  public:
  // .frame.proto.UniformVector3 direction = 5;
  bool has_direction() const;
  void clear_direction() ;
  const ::frame::proto::UniformVector3& direction() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_direction();
  ::frame::proto::UniformVector3* mutable_direction();
  void set_allocated_direction(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_direction(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_direction();

  private:
  const ::frame::proto::UniformVector3& _internal_direction() const;
  ::frame::proto::UniformVector3* _internal_mutable_direction();

  public:
  // .frame.proto.UniformVector3 color = 8;
  bool has_color() const;
  void clear_color() ;
  const ::frame::proto::UniformVector3& color() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_color();
  ::frame::proto::UniformVector3* mutable_color();
  void set_allocated_color(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_color(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_color();

  private:
  const ::frame::proto::UniformVector3& _internal_color() const;
  ::frame::proto::UniformVector3* _internal_mutable_color();

  public:
  // .frame.proto.NodeLight.LightTypeEnum light_type = 3;
  void clear_light_type() ;
  ::frame::proto::NodeLight_LightTypeEnum light_type() const;
  void set_light_type(::frame::proto::NodeLight_LightTypeEnum value);

  private:
  ::frame::proto::NodeLight_LightTypeEnum _internal_light_type() const;
  void _internal_set_light_type(::frame::proto::NodeLight_LightTypeEnum value);

  public:
  // float dot_inner_limit = 6;
  void clear_dot_inner_limit() ;
  float dot_inner_limit() const;
  void set_dot_inner_limit(float value);

  private:
  float _internal_dot_inner_limit() const;
  void _internal_set_dot_inner_limit(float value);

  public:
  // float dot_outer_limit = 7;
  void clear_dot_outer_limit() ;
  float dot_outer_limit() const;
  void set_dot_outer_limit(float value);

  private:
  float _internal_dot_outer_limit() const;
  void _internal_set_dot_outer_limit(float value);

  public:
  // .frame.proto.NodeLight.ShadowTypeEnum shadow_type = 9;
  void clear_shadow_type() ;
  ::frame::proto::NodeLight_ShadowTypeEnum shadow_type() const;
  void set_shadow_type(::frame::proto::NodeLight_ShadowTypeEnum value);

  private:
  ::frame::proto::NodeLight_ShadowTypeEnum _internal_shadow_type() const;
  void _internal_set_shadow_type(::frame::proto::NodeLight_ShadowTypeEnum value);

  public:
  // @@protoc_insertion_point(class_scope:frame.proto.NodeLight)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 3,
      62, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeLight& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    ::google::protobuf::internal::ArenaStringPtr shadow_texture_;
    ::frame::proto::UniformVector3* position_;
    ::frame::proto::UniformVector3* direction_;
    ::frame::proto::UniformVector3* color_;
    int light_type_;
    float dot_inner_limit_;
    float dot_outer_limit_;
    int shadow_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class NodeCamera final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:frame.proto.NodeCamera) */ {
 public:
  inline NodeCamera() : NodeCamera(nullptr) {}
  ~NodeCamera() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeCamera* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeCamera));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeCamera(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeCamera(const NodeCamera& from) : NodeCamera(nullptr, from) {}
  inline NodeCamera(NodeCamera&& from) noexcept
      : NodeCamera(nullptr, std::move(from)) {}
  inline NodeCamera& operator=(const NodeCamera& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeCamera& operator=(NodeCamera&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeCamera& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeCamera* internal_default_instance() {
    return reinterpret_cast<const NodeCamera*>(
        &_NodeCamera_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 2;
  friend void swap(NodeCamera& a, NodeCamera& b) { a.Swap(&b); }
  inline void Swap(NodeCamera* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeCamera* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeCamera* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeCamera>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeCamera& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeCamera& from) { NodeCamera::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeCamera* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "frame.proto.NodeCamera"; }

 protected:
  explicit NodeCamera(::google::protobuf::Arena* arena);
  NodeCamera(::google::protobuf::Arena* arena, const NodeCamera& from);
  NodeCamera(::google::protobuf::Arena* arena, NodeCamera&& from) noexcept
      : NodeCamera(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kPositionFieldNumber = 3,
    kTargetFieldNumber = 4,
    kUpFieldNumber = 5,
    kFovDegreesFieldNumber = 6,
    kAspectRatioFieldNumber = 7,
    kNearClipFieldNumber = 8,
    kFarClipFieldNumber = 9,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string parent = 2;
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // .frame.proto.UniformVector3 position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::frame::proto::UniformVector3& position() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_position();
  ::frame::proto::UniformVector3* mutable_position();
  void set_allocated_position(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_position(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_position();

  private:
  const ::frame::proto::UniformVector3& _internal_position() const;
  ::frame::proto::UniformVector3* _internal_mutable_position();

  public:
  // .frame.proto.UniformVector3 target = 4;
  bool has_target() const;
  void clear_target() ;
  const ::frame::proto::UniformVector3& target() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_target();
  ::frame::proto::UniformVector3* mutable_target();
  void set_allocated_target(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_target(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_target();

  private:
  const ::frame::proto::UniformVector3& _internal_target() const;
  ::frame::proto::UniformVector3* _internal_mutable_target();

  public:
  // .frame.proto.UniformVector3 up = 5;
  bool has_up() const;
  void clear_up() ;
  const ::frame::proto::UniformVector3& up() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_up();
  ::frame::proto::UniformVector3* mutable_up();
  void set_allocated_up(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_up(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_up();

  private:
  const ::frame::proto::UniformVector3& _internal_up() const;
  ::frame::proto::UniformVector3* _internal_mutable_up();

  public:
  // float fov_degrees = 6;
  void clear_fov_degrees() ;
  float fov_degrees() const;
  void set_fov_degrees(float value);

  private:
  float _internal_fov_degrees() const;
  void _internal_set_fov_degrees(float value);

  public:
  // float aspect_ratio = 7;
  void clear_aspect_ratio() ;
  float aspect_ratio() const;
  void set_aspect_ratio(float value);

  private:
  float _internal_aspect_ratio() const;
  void _internal_set_aspect_ratio(float value);

  public:
  // float near_clip = 8;
  void clear_near_clip() ;
  float near_clip() const;
  void set_near_clip(float value);

  private:
  float _internal_near_clip() const;
  void _internal_set_near_clip(float value);

  public:
  // float far_clip = 9;
  void clear_far_clip() ;
  float far_clip() const;
  void set_far_clip(float value);

  private:
  float _internal_far_clip() const;
  void _internal_set_far_clip(float value);

  public:
  // @@protoc_insertion_point(class_scope:frame.proto.NodeCamera)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 3,
      49, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeCamera& from_msg);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    ::frame::proto::UniformVector3* position_;
    ::frame::proto::UniformVector3* target_;
    ::frame::proto::UniformVector3* up_;
    float fov_degrees_;
    float aspect_ratio_;
    float near_clip_;
    float far_clip_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class NodeStaticMesh final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:frame.proto.NodeStaticMesh) */ {
 public:
  inline NodeStaticMesh() : NodeStaticMesh(nullptr) {}
  ~NodeStaticMesh() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(NodeStaticMesh* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(NodeStaticMesh));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR NodeStaticMesh(
      ::google::protobuf::internal::ConstantInitialized);

  inline NodeStaticMesh(const NodeStaticMesh& from) : NodeStaticMesh(nullptr, from) {}
  inline NodeStaticMesh(NodeStaticMesh&& from) noexcept
      : NodeStaticMesh(nullptr, std::move(from)) {}
  inline NodeStaticMesh& operator=(const NodeStaticMesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeStaticMesh& operator=(NodeStaticMesh&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const NodeStaticMesh& default_instance() {
    return *internal_default_instance();
  }
  enum MeshOneofCase {
    kCleanBuffer = 7,
    kMeshEnum = 6,
    kFileName = 3,
    kMultiPlugin = 10,
    MESH_ONEOF_NOT_SET = 0,
  };
  static inline const NodeStaticMesh* internal_default_instance() {
    return reinterpret_cast<const NodeStaticMesh*>(
        &_NodeStaticMesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 1;
  friend void swap(NodeStaticMesh& a, NodeStaticMesh& b) { a.Swap(&b); }
  inline void Swap(NodeStaticMesh* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeStaticMesh* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeStaticMesh* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<NodeStaticMesh>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const NodeStaticMesh& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const NodeStaticMesh& from) { NodeStaticMesh::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(NodeStaticMesh* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "frame.proto.NodeStaticMesh"; }

 protected:
  explicit NodeStaticMesh(::google::protobuf::Arena* arena);
  NodeStaticMesh(::google::protobuf::Arena* arena, const NodeStaticMesh& from);
  NodeStaticMesh(::google::protobuf::Arena* arena, NodeStaticMesh&& from) noexcept
      : NodeStaticMesh(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------
  using RenderPrimitiveEnum = NodeStaticMesh_RenderPrimitiveEnum;
  static constexpr RenderPrimitiveEnum TRIANGLE_PRIMITIVE = NodeStaticMesh_RenderPrimitiveEnum_TRIANGLE_PRIMITIVE;
  static constexpr RenderPrimitiveEnum POINT_PRIMITIVE = NodeStaticMesh_RenderPrimitiveEnum_POINT_PRIMITIVE;
  static constexpr RenderPrimitiveEnum LINE_PRIMITIVE = NodeStaticMesh_RenderPrimitiveEnum_LINE_PRIMITIVE;
  static inline bool RenderPrimitiveEnum_IsValid(int value) {
    return NodeStaticMesh_RenderPrimitiveEnum_IsValid(value);
  }
  static constexpr RenderPrimitiveEnum RenderPrimitiveEnum_MIN = NodeStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MIN;
  static constexpr RenderPrimitiveEnum RenderPrimitiveEnum_MAX = NodeStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MAX;
  static constexpr int RenderPrimitiveEnum_ARRAYSIZE = NodeStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RenderPrimitiveEnum_descriptor() {
    return NodeStaticMesh_RenderPrimitiveEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& RenderPrimitiveEnum_Name(T value) {
    return NodeStaticMesh_RenderPrimitiveEnum_Name(value);
  }
  static inline bool RenderPrimitiveEnum_Parse(absl::string_view name, RenderPrimitiveEnum* value) {
    return NodeStaticMesh_RenderPrimitiveEnum_Parse(name, value);
  }
  using MeshEnum = NodeStaticMesh_MeshEnum;
  static constexpr MeshEnum INVALID = NodeStaticMesh_MeshEnum_INVALID;
  static constexpr MeshEnum CUBE = NodeStaticMesh_MeshEnum_CUBE;
  static constexpr MeshEnum QUAD = NodeStaticMesh_MeshEnum_QUAD;
  static inline bool MeshEnum_IsValid(int value) {
    return NodeStaticMesh_MeshEnum_IsValid(value);
  }
  static constexpr MeshEnum MeshEnum_MIN = NodeStaticMesh_MeshEnum_MeshEnum_MIN;
  static constexpr MeshEnum MeshEnum_MAX = NodeStaticMesh_MeshEnum_MeshEnum_MAX;
  static constexpr int MeshEnum_ARRAYSIZE = NodeStaticMesh_MeshEnum_MeshEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MeshEnum_descriptor() {
    return NodeStaticMesh_MeshEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& MeshEnum_Name(T value) {
    return NodeStaticMesh_MeshEnum_Name(value);
  }
  static inline bool MeshEnum_Parse(absl::string_view name, MeshEnum* value) {
    return NodeStaticMesh_MeshEnum_Parse(name, value);
  }
  using RenderTimeEnum = NodeStaticMesh_RenderTimeEnum;
  static constexpr RenderTimeEnum SCENE_RENDER_TIME = NodeStaticMesh_RenderTimeEnum_SCENE_RENDER_TIME;
  static constexpr RenderTimeEnum PRE_RENDER_TIME = NodeStaticMesh_RenderTimeEnum_PRE_RENDER_TIME;
  static constexpr RenderTimeEnum POST_PROCESS_TIME = NodeStaticMesh_RenderTimeEnum_POST_PROCESS_TIME;
  static constexpr RenderTimeEnum SKYBOX_RENDER_TIME = NodeStaticMesh_RenderTimeEnum_SKYBOX_RENDER_TIME;
  static constexpr RenderTimeEnum SHADOW_RENDER_TIME = NodeStaticMesh_RenderTimeEnum_SHADOW_RENDER_TIME;
  static inline bool RenderTimeEnum_IsValid(int value) {
    return NodeStaticMesh_RenderTimeEnum_IsValid(value);
  }
  static constexpr RenderTimeEnum RenderTimeEnum_MIN = NodeStaticMesh_RenderTimeEnum_RenderTimeEnum_MIN;
  static constexpr RenderTimeEnum RenderTimeEnum_MAX = NodeStaticMesh_RenderTimeEnum_RenderTimeEnum_MAX;
  static constexpr int RenderTimeEnum_ARRAYSIZE = NodeStaticMesh_RenderTimeEnum_RenderTimeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RenderTimeEnum_descriptor() {
    return NodeStaticMesh_RenderTimeEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& RenderTimeEnum_Name(T value) {
    return NodeStaticMesh_RenderTimeEnum_Name(value);
  }
  static inline bool RenderTimeEnum_Parse(absl::string_view name, RenderTimeEnum* value) {
    return NodeStaticMesh_RenderTimeEnum_Parse(name, value);
  }
  using ShadowEffectEnum = NodeStaticMesh_ShadowEffectEnum;
  static constexpr ShadowEffectEnum OPAQUE_SHADOW_EFFECT = NodeStaticMesh_ShadowEffectEnum_OPAQUE_SHADOW_EFFECT;
  static constexpr ShadowEffectEnum TRANSPARENT_SHADOW_EFFECT = NodeStaticMesh_ShadowEffectEnum_TRANSPARENT_SHADOW_EFFECT;
  static inline bool ShadowEffectEnum_IsValid(int value) {
    return NodeStaticMesh_ShadowEffectEnum_IsValid(value);
  }
  static constexpr ShadowEffectEnum ShadowEffectEnum_MIN = NodeStaticMesh_ShadowEffectEnum_ShadowEffectEnum_MIN;
  static constexpr ShadowEffectEnum ShadowEffectEnum_MAX = NodeStaticMesh_ShadowEffectEnum_ShadowEffectEnum_MAX;
  static constexpr int ShadowEffectEnum_ARRAYSIZE = NodeStaticMesh_ShadowEffectEnum_ShadowEffectEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ShadowEffectEnum_descriptor() {
    return NodeStaticMesh_ShadowEffectEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& ShadowEffectEnum_Name(T value) {
    return NodeStaticMesh_ShadowEffectEnum_Name(value);
  }
  static inline bool ShadowEffectEnum_Parse(absl::string_view name, ShadowEffectEnum* value) {
    return NodeStaticMesh_ShadowEffectEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------
  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kMaterialNameFieldNumber = 5,
    kRenderPrimitiveEnumFieldNumber = 8,
    kRenderTimeEnumFieldNumber = 11,
    kShadowEffectEnumFieldNumber = 12,
    kCleanBufferFieldNumber = 7,
    kMeshEnumFieldNumber = 6,
    kFileNameFieldNumber = 3,
    kMultiPluginFieldNumber = 10,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string parent = 2;
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // string material_name = 5;
  void clear_material_name() ;
  const std::string& material_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_material_name(Arg_&& arg, Args_... args);
  std::string* mutable_material_name();
  PROTOBUF_NODISCARD std::string* release_material_name();
  void set_allocated_material_name(std::string* value);

  private:
  const std::string& _internal_material_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_material_name(
      const std::string& value);
  std::string* _internal_mutable_material_name();

  public:
  // .frame.proto.NodeStaticMesh.RenderPrimitiveEnum render_primitive_enum = 8;
  void clear_render_primitive_enum() ;
  ::frame::proto::NodeStaticMesh_RenderPrimitiveEnum render_primitive_enum() const;
  void set_render_primitive_enum(::frame::proto::NodeStaticMesh_RenderPrimitiveEnum value);

  private:
  ::frame::proto::NodeStaticMesh_RenderPrimitiveEnum _internal_render_primitive_enum() const;
  void _internal_set_render_primitive_enum(::frame::proto::NodeStaticMesh_RenderPrimitiveEnum value);

  public:
  // .frame.proto.NodeStaticMesh.RenderTimeEnum render_time_enum = 11;
  void clear_render_time_enum() ;
  ::frame::proto::NodeStaticMesh_RenderTimeEnum render_time_enum() const;
  void set_render_time_enum(::frame::proto::NodeStaticMesh_RenderTimeEnum value);

  private:
  ::frame::proto::NodeStaticMesh_RenderTimeEnum _internal_render_time_enum() const;
  void _internal_set_render_time_enum(::frame::proto::NodeStaticMesh_RenderTimeEnum value);

  public:
  // .frame.proto.NodeStaticMesh.ShadowEffectEnum shadow_effect_enum = 12;
  void clear_shadow_effect_enum() ;
  ::frame::proto::NodeStaticMesh_ShadowEffectEnum shadow_effect_enum() const;
  void set_shadow_effect_enum(::frame::proto::NodeStaticMesh_ShadowEffectEnum value);

  private:
  ::frame::proto::NodeStaticMesh_ShadowEffectEnum _internal_shadow_effect_enum() const;
  void _internal_set_shadow_effect_enum(::frame::proto::NodeStaticMesh_ShadowEffectEnum value);

  public:
  // .frame.proto.CleanBuffer clean_buffer = 7;
  bool has_clean_buffer() const;
  private:
  bool _internal_has_clean_buffer() const;

  public:
  void clear_clean_buffer() ;
  const ::frame::proto::CleanBuffer& clean_buffer() const;
  PROTOBUF_NODISCARD ::frame::proto::CleanBuffer* release_clean_buffer();
  ::frame::proto::CleanBuffer* mutable_clean_buffer();
  void set_allocated_clean_buffer(::frame::proto::CleanBuffer* value);
  void unsafe_arena_set_allocated_clean_buffer(::frame::proto::CleanBuffer* value);
  ::frame::proto::CleanBuffer* unsafe_arena_release_clean_buffer();

  private:
  const ::frame::proto::CleanBuffer& _internal_clean_buffer() const;
  ::frame::proto::CleanBuffer* _internal_mutable_clean_buffer();

  public:
  // .frame.proto.NodeStaticMesh.MeshEnum mesh_enum = 6;
  bool has_mesh_enum() const;
  void clear_mesh_enum() ;
  ::frame::proto::NodeStaticMesh_MeshEnum mesh_enum() const;
  void set_mesh_enum(::frame::proto::NodeStaticMesh_MeshEnum value);

  private:
  ::frame::proto::NodeStaticMesh_MeshEnum _internal_mesh_enum() const;
  void _internal_set_mesh_enum(::frame::proto::NodeStaticMesh_MeshEnum value);

  public:
  // string file_name = 3;
  bool has_file_name() const;
  void clear_file_name() ;
  const std::string& file_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_name(Arg_&& arg, Args_... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* value);

  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
      const std::string& value);
  std::string* _internal_mutable_file_name();

  public:
  // .frame.proto.MultiPlugin multi_plugin = 10;
  bool has_multi_plugin() const;
  private:
  bool _internal_has_multi_plugin() const;

  public:
  void clear_multi_plugin() ;
  const ::frame::proto::MultiPlugin& multi_plugin() const;
  PROTOBUF_NODISCARD ::frame::proto::MultiPlugin* release_multi_plugin();
  ::frame::proto::MultiPlugin* mutable_multi_plugin();
  void set_allocated_multi_plugin(::frame::proto::MultiPlugin* value);
  void unsafe_arena_set_allocated_multi_plugin(::frame::proto::MultiPlugin* value);
  ::frame::proto::MultiPlugin* unsafe_arena_release_multi_plugin();

  private:
  const ::frame::proto::MultiPlugin& _internal_multi_plugin() const;
  ::frame::proto::MultiPlugin* _internal_mutable_multi_plugin();

  public:
  void clear_mesh_oneof();
  MeshOneofCase mesh_oneof_case() const;
  // @@protoc_insertion_point(class_scope:frame.proto.NodeStaticMesh)
 private:
  class _Internal;
  void set_has_clean_buffer();
  void set_has_mesh_enum();
  void set_has_file_name();
  void set_has_multi_plugin();
  inline bool has_mesh_oneof() const;
  inline void clear_has_mesh_oneof();
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 10, 2,
      75, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const NodeStaticMesh& from_msg);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    ::google::protobuf::internal::ArenaStringPtr material_name_;
    int render_primitive_enum_;
    int render_time_enum_;
    int shadow_effect_enum_;
    union MeshOneofUnion {
      constexpr MeshOneofUnion() : _constinit_{} {}
      ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::frame::proto::CleanBuffer* clean_buffer_;
      int mesh_enum_;
      ::google::protobuf::internal::ArenaStringPtr file_name_;
      ::frame::proto::MultiPlugin* multi_plugin_;
    } mesh_oneof_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class SceneTree final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:frame.proto.SceneTree) */ {
 public:
  inline SceneTree() : SceneTree(nullptr) {}
  ~SceneTree() PROTOBUF_FINAL;

#if defined(PROTOBUF_CUSTOM_VTABLE)
  void operator delete(SceneTree* msg, std::destroying_delete_t) {
    SharedDtor(*msg);
    ::google::protobuf::internal::SizedDelete(msg, sizeof(SceneTree));
  }
#endif

  template <typename = void>
  explicit PROTOBUF_CONSTEXPR SceneTree(
      ::google::protobuf::internal::ConstantInitialized);

  inline SceneTree(const SceneTree& from) : SceneTree(nullptr, from) {}
  inline SceneTree(SceneTree&& from) noexcept
      : SceneTree(nullptr, std::move(from)) {}
  inline SceneTree& operator=(const SceneTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneTree& operator=(SceneTree&& from) noexcept {
    if (this == &from) return *this;
    if (::google::protobuf::internal::CanMoveWithInternalSwap(GetArena(), from.GetArena())) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const SceneTree* internal_default_instance() {
    return reinterpret_cast<const SceneTree*>(
        &_SceneTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages = 4;
  friend void swap(SceneTree& a, SceneTree& b) { a.Swap(&b); }
  inline void Swap(SceneTree* other) {
    if (other == this) return;
    if (::google::protobuf::internal::CanUseInternalSwap(GetArena(), other->GetArena())) {
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneTree* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneTree* New(::google::protobuf::Arena* arena = nullptr) const {
    return ::google::protobuf::Message::DefaultConstruct<SceneTree>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SceneTree& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom(const SceneTree& from) { SceneTree::MergeImpl(*this, from); }

  private:
  static void MergeImpl(
      ::google::protobuf::MessageLite& to_msg,
      const ::google::protobuf::MessageLite& from_msg);

  public:
  bool IsInitialized() const {
    return true;
  }
  ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
  #if defined(PROTOBUF_CUSTOM_VTABLE)
  private:
  static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
  static ::uint8_t* _InternalSerialize(
      const MessageLite& msg, ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream);

  public:
  ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const {
    return _InternalSerialize(*this, target, stream);
  }
  #else   // PROTOBUF_CUSTOM_VTABLE
  ::size_t ByteSizeLong() const final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target,
      ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  #endif  // PROTOBUF_CUSTOM_VTABLE
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::google::protobuf::Arena* arena);
  static void SharedDtor(MessageLite& self);
  void InternalSwap(SceneTree* other);
 private:
  template <typename T>
  friend ::absl::string_view(
      ::google::protobuf::internal::GetAnyMessageName)();
  static ::absl::string_view FullMessageName() { return "frame.proto.SceneTree"; }

 protected:
  explicit SceneTree(::google::protobuf::Arena* arena);
  SceneTree(::google::protobuf::Arena* arena, const SceneTree& from);
  SceneTree(::google::protobuf::Arena* arena, SceneTree&& from) noexcept
      : SceneTree(arena) {
    *this = ::std::move(from);
  }
  const ::google::protobuf::internal::ClassData* GetClassData() const PROTOBUF_FINAL;
  static void* PlacementNew_(const void*, void* mem,
                             ::google::protobuf::Arena* arena);
  static constexpr auto InternalNewImpl_();
  static const ::google::protobuf::internal::ClassDataFull _class_data_;

 public:
  ::google::protobuf::Metadata GetMetadata() const;
  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------
  enum : int {
    kNodeMatricesFieldNumber = 3,
    kNodeStaticMeshesFieldNumber = 4,
    kNodeCamerasFieldNumber = 5,
    kNodeLightsFieldNumber = 6,
    kDefaultRootNameFieldNumber = 1,
    kDefaultCameraNameFieldNumber = 2,
  };
  // repeated .frame.proto.NodeMatrix node_matrices = 3;
  int node_matrices_size() const;
  private:
  int _internal_node_matrices_size() const;

  public:
  void clear_node_matrices() ;
  ::frame::proto::NodeMatrix* mutable_node_matrices(int index);
  ::google::protobuf::RepeatedPtrField<::frame::proto::NodeMatrix>* mutable_node_matrices();

  private:
  const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeMatrix>& _internal_node_matrices() const;
  ::google::protobuf::RepeatedPtrField<::frame::proto::NodeMatrix>* _internal_mutable_node_matrices();
  public:
  const ::frame::proto::NodeMatrix& node_matrices(int index) const;
  ::frame::proto::NodeMatrix* add_node_matrices();
  const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeMatrix>& node_matrices() const;
  // repeated .frame.proto.NodeStaticMesh node_static_meshes = 4;
  int node_static_meshes_size() const;
  private:
  int _internal_node_static_meshes_size() const;

  public:
  void clear_node_static_meshes() ;
  ::frame::proto::NodeStaticMesh* mutable_node_static_meshes(int index);
  ::google::protobuf::RepeatedPtrField<::frame::proto::NodeStaticMesh>* mutable_node_static_meshes();

  private:
  const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeStaticMesh>& _internal_node_static_meshes() const;
  ::google::protobuf::RepeatedPtrField<::frame::proto::NodeStaticMesh>* _internal_mutable_node_static_meshes();
  public:
  const ::frame::proto::NodeStaticMesh& node_static_meshes(int index) const;
  ::frame::proto::NodeStaticMesh* add_node_static_meshes();
  const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeStaticMesh>& node_static_meshes() const;
  // repeated .frame.proto.NodeCamera node_cameras = 5;
  int node_cameras_size() const;
  private:
  int _internal_node_cameras_size() const;

  public:
  void clear_node_cameras() ;
  ::frame::proto::NodeCamera* mutable_node_cameras(int index);
  ::google::protobuf::RepeatedPtrField<::frame::proto::NodeCamera>* mutable_node_cameras();

  private:
  const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeCamera>& _internal_node_cameras() const;
  ::google::protobuf::RepeatedPtrField<::frame::proto::NodeCamera>* _internal_mutable_node_cameras();
  public:
  const ::frame::proto::NodeCamera& node_cameras(int index) const;
  ::frame::proto::NodeCamera* add_node_cameras();
  const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeCamera>& node_cameras() const;
  // repeated .frame.proto.NodeLight node_lights = 6;
  int node_lights_size() const;
  private:
  int _internal_node_lights_size() const;

  public:
  void clear_node_lights() ;
  ::frame::proto::NodeLight* mutable_node_lights(int index);
  ::google::protobuf::RepeatedPtrField<::frame::proto::NodeLight>* mutable_node_lights();

  private:
  const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeLight>& _internal_node_lights() const;
  ::google::protobuf::RepeatedPtrField<::frame::proto::NodeLight>* _internal_mutable_node_lights();
  public:
  const ::frame::proto::NodeLight& node_lights(int index) const;
  ::frame::proto::NodeLight* add_node_lights();
  const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeLight>& node_lights() const;
  // string default_root_name = 1;
  void clear_default_root_name() ;
  const std::string& default_root_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_root_name(Arg_&& arg, Args_... args);
  std::string* mutable_default_root_name();
  PROTOBUF_NODISCARD std::string* release_default_root_name();
  void set_allocated_default_root_name(std::string* value);

  private:
  const std::string& _internal_default_root_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_root_name(
      const std::string& value);
  std::string* _internal_mutable_default_root_name();

  public:
  // string default_camera_name = 2;
  void clear_default_camera_name() ;
  const std::string& default_camera_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_camera_name(Arg_&& arg, Args_... args);
  std::string* mutable_default_camera_name();
  PROTOBUF_NODISCARD std::string* release_default_camera_name();
  void set_allocated_default_camera_name(std::string* value);

  private:
  const std::string& _internal_default_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_camera_name(
      const std::string& value);
  std::string* _internal_mutable_default_camera_name();

  public:
  // @@protoc_insertion_point(class_scope:frame.proto.SceneTree)
 private:
  class _Internal;
  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 4,
      66, 2>
      _table_;

  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {
    inline explicit constexpr Impl_(
        ::google::protobuf::internal::ConstantInitialized) noexcept;
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena);
    inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                          ::google::protobuf::Arena* arena, const Impl_& from,
                          const SceneTree& from_msg);
    ::google::protobuf::RepeatedPtrField< ::frame::proto::NodeMatrix > node_matrices_;
    ::google::protobuf::RepeatedPtrField< ::frame::proto::NodeStaticMesh > node_static_meshes_;
    ::google::protobuf::RepeatedPtrField< ::frame::proto::NodeCamera > node_cameras_;
    ::google::protobuf::RepeatedPtrField< ::frame::proto::NodeLight > node_lights_;
    ::google::protobuf::internal::ArenaStringPtr default_root_name_;
    ::google::protobuf::internal::ArenaStringPtr default_camera_name_;
    ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// NodeMatrix

// string name = 1;
inline void NodeMatrix::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeMatrix::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeMatrix.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeMatrix::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeMatrix.name)
}
inline std::string* NodeMatrix::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeMatrix.name)
  return _s;
}
inline const std::string& NodeMatrix::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void NodeMatrix::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NodeMatrix::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NodeMatrix::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeMatrix.name)
  return _impl_.name_.Release();
}
inline void NodeMatrix::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeMatrix.name)
}

// string parent = 2;
inline void NodeMatrix::clear_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& NodeMatrix::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeMatrix.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeMatrix::set_parent(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeMatrix.parent)
}
inline std::string* NodeMatrix::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeMatrix.parent)
  return _s;
}
inline const std::string& NodeMatrix::_internal_parent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_.Get();
}
inline void NodeMatrix::_internal_set_parent(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* NodeMatrix::_internal_mutable_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* NodeMatrix::release_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeMatrix.parent)
  return _impl_.parent_.Release();
}
inline void NodeMatrix::set_allocated_parent(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeMatrix.parent)
}

// .frame.proto.NodeMatrix.MatrixTypeEnum matrix_type_enum = 5;
inline void NodeMatrix::clear_matrix_type_enum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.matrix_type_enum_ = 0;
}
inline ::frame::proto::NodeMatrix_MatrixTypeEnum NodeMatrix::matrix_type_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeMatrix.matrix_type_enum)
  return _internal_matrix_type_enum();
}
inline void NodeMatrix::set_matrix_type_enum(::frame::proto::NodeMatrix_MatrixTypeEnum value) {
  _internal_set_matrix_type_enum(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeMatrix.matrix_type_enum)
}
inline ::frame::proto::NodeMatrix_MatrixTypeEnum NodeMatrix::_internal_matrix_type_enum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::frame::proto::NodeMatrix_MatrixTypeEnum>(_impl_.matrix_type_enum_);
}
inline void NodeMatrix::_internal_set_matrix_type_enum(::frame::proto::NodeMatrix_MatrixTypeEnum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.matrix_type_enum_ = value;
}

// .frame.proto.UniformMatrix4 matrix = 3;
inline bool NodeMatrix::has_matrix() const {
  return matrix_oneof_case() == kMatrix;
}
inline bool NodeMatrix::_internal_has_matrix() const {
  return matrix_oneof_case() == kMatrix;
}
inline void NodeMatrix::set_has_matrix() {
  _impl_._oneof_case_[0] = kMatrix;
}
inline ::frame::proto::UniformMatrix4* NodeMatrix::release_matrix() {
  // @@protoc_insertion_point(field_release:frame.proto.NodeMatrix.matrix)
  if (matrix_oneof_case() == kMatrix) {
    clear_has_matrix_oneof();
    auto* temp = _impl_.matrix_oneof_.matrix_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.matrix_oneof_.matrix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::frame::proto::UniformMatrix4& NodeMatrix::_internal_matrix() const {
  return matrix_oneof_case() == kMatrix ? *_impl_.matrix_oneof_.matrix_ : reinterpret_cast<::frame::proto::UniformMatrix4&>(::frame::proto::_UniformMatrix4_default_instance_);
}
inline const ::frame::proto::UniformMatrix4& NodeMatrix::matrix() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeMatrix.matrix)
  return _internal_matrix();
}
inline ::frame::proto::UniformMatrix4* NodeMatrix::unsafe_arena_release_matrix() {
  // @@protoc_insertion_point(field_unsafe_arena_release:frame.proto.NodeMatrix.matrix)
  if (matrix_oneof_case() == kMatrix) {
    clear_has_matrix_oneof();
    auto* temp = _impl_.matrix_oneof_.matrix_;
    _impl_.matrix_oneof_.matrix_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeMatrix::unsafe_arena_set_allocated_matrix(::frame::proto::UniformMatrix4* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_matrix_oneof();
  if (value) {
    set_has_matrix();
    _impl_.matrix_oneof_.matrix_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.NodeMatrix.matrix)
}
inline ::frame::proto::UniformMatrix4* NodeMatrix::_internal_mutable_matrix() {
  if (matrix_oneof_case() != kMatrix) {
    clear_matrix_oneof();
    set_has_matrix();
    _impl_.matrix_oneof_.matrix_ =
        ::google::protobuf::Message::DefaultConstruct<::frame::proto::UniformMatrix4>(GetArena());
  }
  return _impl_.matrix_oneof_.matrix_;
}
inline ::frame::proto::UniformMatrix4* NodeMatrix::mutable_matrix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::UniformMatrix4* _msg = _internal_mutable_matrix();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeMatrix.matrix)
  return _msg;
}

// .frame.proto.UniformVector4 quaternion = 4;
inline bool NodeMatrix::has_quaternion() const {
  return matrix_oneof_case() == kQuaternion;
}
inline bool NodeMatrix::_internal_has_quaternion() const {
  return matrix_oneof_case() == kQuaternion;
}
inline void NodeMatrix::set_has_quaternion() {
  _impl_._oneof_case_[0] = kQuaternion;
}
inline ::frame::proto::UniformVector4* NodeMatrix::release_quaternion() {
  // @@protoc_insertion_point(field_release:frame.proto.NodeMatrix.quaternion)
  if (matrix_oneof_case() == kQuaternion) {
    clear_has_matrix_oneof();
    auto* temp = _impl_.matrix_oneof_.quaternion_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.matrix_oneof_.quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::frame::proto::UniformVector4& NodeMatrix::_internal_quaternion() const {
  return matrix_oneof_case() == kQuaternion ? *_impl_.matrix_oneof_.quaternion_ : reinterpret_cast<::frame::proto::UniformVector4&>(::frame::proto::_UniformVector4_default_instance_);
}
inline const ::frame::proto::UniformVector4& NodeMatrix::quaternion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeMatrix.quaternion)
  return _internal_quaternion();
}
inline ::frame::proto::UniformVector4* NodeMatrix::unsafe_arena_release_quaternion() {
  // @@protoc_insertion_point(field_unsafe_arena_release:frame.proto.NodeMatrix.quaternion)
  if (matrix_oneof_case() == kQuaternion) {
    clear_has_matrix_oneof();
    auto* temp = _impl_.matrix_oneof_.quaternion_;
    _impl_.matrix_oneof_.quaternion_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeMatrix::unsafe_arena_set_allocated_quaternion(::frame::proto::UniformVector4* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_matrix_oneof();
  if (value) {
    set_has_quaternion();
    _impl_.matrix_oneof_.quaternion_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.NodeMatrix.quaternion)
}
inline ::frame::proto::UniformVector4* NodeMatrix::_internal_mutable_quaternion() {
  if (matrix_oneof_case() != kQuaternion) {
    clear_matrix_oneof();
    set_has_quaternion();
    _impl_.matrix_oneof_.quaternion_ =
        ::google::protobuf::Message::DefaultConstruct<::frame::proto::UniformVector4>(GetArena());
  }
  return _impl_.matrix_oneof_.quaternion_;
}
inline ::frame::proto::UniformVector4* NodeMatrix::mutable_quaternion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::UniformVector4* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeMatrix.quaternion)
  return _msg;
}

inline bool NodeMatrix::has_matrix_oneof() const {
  return matrix_oneof_case() != MATRIX_ONEOF_NOT_SET;
}
inline void NodeMatrix::clear_has_matrix_oneof() {
  _impl_._oneof_case_[0] = MATRIX_ONEOF_NOT_SET;
}
inline NodeMatrix::MatrixOneofCase NodeMatrix::matrix_oneof_case() const {
  return NodeMatrix::MatrixOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NodeStaticMesh

// string name = 1;
inline void NodeStaticMesh::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeStaticMesh::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeStaticMesh.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeStaticMesh::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeStaticMesh.name)
}
inline std::string* NodeStaticMesh::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeStaticMesh.name)
  return _s;
}
inline const std::string& NodeStaticMesh::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void NodeStaticMesh::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NodeStaticMesh::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NodeStaticMesh::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeStaticMesh.name)
  return _impl_.name_.Release();
}
inline void NodeStaticMesh::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeStaticMesh.name)
}

// string parent = 2;
inline void NodeStaticMesh::clear_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& NodeStaticMesh::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeStaticMesh.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeStaticMesh::set_parent(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeStaticMesh.parent)
}
inline std::string* NodeStaticMesh::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeStaticMesh.parent)
  return _s;
}
inline const std::string& NodeStaticMesh::_internal_parent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_.Get();
}
inline void NodeStaticMesh::_internal_set_parent(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* NodeStaticMesh::_internal_mutable_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* NodeStaticMesh::release_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeStaticMesh.parent)
  return _impl_.parent_.Release();
}
inline void NodeStaticMesh::set_allocated_parent(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeStaticMesh.parent)
}

// .frame.proto.NodeStaticMesh.RenderPrimitiveEnum render_primitive_enum = 8;
inline void NodeStaticMesh::clear_render_primitive_enum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.render_primitive_enum_ = 0;
}
inline ::frame::proto::NodeStaticMesh_RenderPrimitiveEnum NodeStaticMesh::render_primitive_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeStaticMesh.render_primitive_enum)
  return _internal_render_primitive_enum();
}
inline void NodeStaticMesh::set_render_primitive_enum(::frame::proto::NodeStaticMesh_RenderPrimitiveEnum value) {
  _internal_set_render_primitive_enum(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeStaticMesh.render_primitive_enum)
}
inline ::frame::proto::NodeStaticMesh_RenderPrimitiveEnum NodeStaticMesh::_internal_render_primitive_enum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::frame::proto::NodeStaticMesh_RenderPrimitiveEnum>(_impl_.render_primitive_enum_);
}
inline void NodeStaticMesh::_internal_set_render_primitive_enum(::frame::proto::NodeStaticMesh_RenderPrimitiveEnum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.render_primitive_enum_ = value;
}

// .frame.proto.CleanBuffer clean_buffer = 7;
inline bool NodeStaticMesh::has_clean_buffer() const {
  return mesh_oneof_case() == kCleanBuffer;
}
inline bool NodeStaticMesh::_internal_has_clean_buffer() const {
  return mesh_oneof_case() == kCleanBuffer;
}
inline void NodeStaticMesh::set_has_clean_buffer() {
  _impl_._oneof_case_[0] = kCleanBuffer;
}
inline ::frame::proto::CleanBuffer* NodeStaticMesh::release_clean_buffer() {
  // @@protoc_insertion_point(field_release:frame.proto.NodeStaticMesh.clean_buffer)
  if (mesh_oneof_case() == kCleanBuffer) {
    clear_has_mesh_oneof();
    auto* temp = _impl_.mesh_oneof_.clean_buffer_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mesh_oneof_.clean_buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::frame::proto::CleanBuffer& NodeStaticMesh::_internal_clean_buffer() const {
  return mesh_oneof_case() == kCleanBuffer ? *_impl_.mesh_oneof_.clean_buffer_ : reinterpret_cast<::frame::proto::CleanBuffer&>(::frame::proto::_CleanBuffer_default_instance_);
}
inline const ::frame::proto::CleanBuffer& NodeStaticMesh::clean_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeStaticMesh.clean_buffer)
  return _internal_clean_buffer();
}
inline ::frame::proto::CleanBuffer* NodeStaticMesh::unsafe_arena_release_clean_buffer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:frame.proto.NodeStaticMesh.clean_buffer)
  if (mesh_oneof_case() == kCleanBuffer) {
    clear_has_mesh_oneof();
    auto* temp = _impl_.mesh_oneof_.clean_buffer_;
    _impl_.mesh_oneof_.clean_buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeStaticMesh::unsafe_arena_set_allocated_clean_buffer(::frame::proto::CleanBuffer* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mesh_oneof();
  if (value) {
    set_has_clean_buffer();
    _impl_.mesh_oneof_.clean_buffer_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.NodeStaticMesh.clean_buffer)
}
inline ::frame::proto::CleanBuffer* NodeStaticMesh::_internal_mutable_clean_buffer() {
  if (mesh_oneof_case() != kCleanBuffer) {
    clear_mesh_oneof();
    set_has_clean_buffer();
    _impl_.mesh_oneof_.clean_buffer_ =
        ::google::protobuf::Message::DefaultConstruct<::frame::proto::CleanBuffer>(GetArena());
  }
  return _impl_.mesh_oneof_.clean_buffer_;
}
inline ::frame::proto::CleanBuffer* NodeStaticMesh::mutable_clean_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::CleanBuffer* _msg = _internal_mutable_clean_buffer();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeStaticMesh.clean_buffer)
  return _msg;
}

// .frame.proto.NodeStaticMesh.MeshEnum mesh_enum = 6;
inline bool NodeStaticMesh::has_mesh_enum() const {
  return mesh_oneof_case() == kMeshEnum;
}
inline void NodeStaticMesh::set_has_mesh_enum() {
  _impl_._oneof_case_[0] = kMeshEnum;
}
inline void NodeStaticMesh::clear_mesh_enum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (mesh_oneof_case() == kMeshEnum) {
    _impl_.mesh_oneof_.mesh_enum_ = 0;
    clear_has_mesh_oneof();
  }
}
inline ::frame::proto::NodeStaticMesh_MeshEnum NodeStaticMesh::mesh_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeStaticMesh.mesh_enum)
  return _internal_mesh_enum();
}
inline void NodeStaticMesh::set_mesh_enum(::frame::proto::NodeStaticMesh_MeshEnum value) {
  if (mesh_oneof_case() != kMeshEnum) {
    clear_mesh_oneof();
    set_has_mesh_enum();
  }
  _impl_.mesh_oneof_.mesh_enum_ = value;
  // @@protoc_insertion_point(field_set:frame.proto.NodeStaticMesh.mesh_enum)
}
inline ::frame::proto::NodeStaticMesh_MeshEnum NodeStaticMesh::_internal_mesh_enum() const {
  if (mesh_oneof_case() == kMeshEnum) {
    return static_cast<::frame::proto::NodeStaticMesh_MeshEnum>(_impl_.mesh_oneof_.mesh_enum_);
  }
  return static_cast<::frame::proto::NodeStaticMesh_MeshEnum>(0);
}

// string file_name = 3;
inline bool NodeStaticMesh::has_file_name() const {
  return mesh_oneof_case() == kFileName;
}
inline void NodeStaticMesh::set_has_file_name() {
  _impl_._oneof_case_[0] = kFileName;
}
inline void NodeStaticMesh::clear_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (mesh_oneof_case() == kFileName) {
    _impl_.mesh_oneof_.file_name_.Destroy();
    clear_has_mesh_oneof();
  }
}
inline const std::string& NodeStaticMesh::file_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeStaticMesh.file_name)
  return _internal_file_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeStaticMesh::set_file_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (mesh_oneof_case() != kFileName) {
    clear_mesh_oneof();

    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitDefault();
  }
  _impl_.mesh_oneof_.file_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeStaticMesh.file_name)
}
inline std::string* NodeStaticMesh::mutable_file_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeStaticMesh.file_name)
  return _s;
}
inline const std::string& NodeStaticMesh::_internal_file_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  if (mesh_oneof_case() != kFileName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.mesh_oneof_.file_name_.Get();
}
inline void NodeStaticMesh::_internal_set_file_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (mesh_oneof_case() != kFileName) {
    clear_mesh_oneof();

    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitDefault();
  }
  _impl_.mesh_oneof_.file_name_.Set(value, GetArena());
}
inline std::string* NodeStaticMesh::_internal_mutable_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (mesh_oneof_case() != kFileName) {
    clear_mesh_oneof();

    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitDefault();
  }
  return _impl_.mesh_oneof_.file_name_.Mutable( GetArena());
}
inline std::string* NodeStaticMesh::release_file_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeStaticMesh.file_name)
  if (mesh_oneof_case() != kFileName) {
    return nullptr;
  }
  clear_has_mesh_oneof();
  return _impl_.mesh_oneof_.file_name_.Release();
}
inline void NodeStaticMesh::set_allocated_file_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (has_mesh_oneof()) {
    clear_mesh_oneof();
  }
  if (value != nullptr) {
    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeStaticMesh.file_name)
}

// .frame.proto.MultiPlugin multi_plugin = 10;
inline bool NodeStaticMesh::has_multi_plugin() const {
  return mesh_oneof_case() == kMultiPlugin;
}
inline bool NodeStaticMesh::_internal_has_multi_plugin() const {
  return mesh_oneof_case() == kMultiPlugin;
}
inline void NodeStaticMesh::set_has_multi_plugin() {
  _impl_._oneof_case_[0] = kMultiPlugin;
}
inline ::frame::proto::MultiPlugin* NodeStaticMesh::release_multi_plugin() {
  // @@protoc_insertion_point(field_release:frame.proto.NodeStaticMesh.multi_plugin)
  if (mesh_oneof_case() == kMultiPlugin) {
    clear_has_mesh_oneof();
    auto* temp = _impl_.mesh_oneof_.multi_plugin_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mesh_oneof_.multi_plugin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::frame::proto::MultiPlugin& NodeStaticMesh::_internal_multi_plugin() const {
  return mesh_oneof_case() == kMultiPlugin ? *_impl_.mesh_oneof_.multi_plugin_ : reinterpret_cast<::frame::proto::MultiPlugin&>(::frame::proto::_MultiPlugin_default_instance_);
}
inline const ::frame::proto::MultiPlugin& NodeStaticMesh::multi_plugin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeStaticMesh.multi_plugin)
  return _internal_multi_plugin();
}
inline ::frame::proto::MultiPlugin* NodeStaticMesh::unsafe_arena_release_multi_plugin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:frame.proto.NodeStaticMesh.multi_plugin)
  if (mesh_oneof_case() == kMultiPlugin) {
    clear_has_mesh_oneof();
    auto* temp = _impl_.mesh_oneof_.multi_plugin_;
    _impl_.mesh_oneof_.multi_plugin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void NodeStaticMesh::unsafe_arena_set_allocated_multi_plugin(::frame::proto::MultiPlugin* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mesh_oneof();
  if (value) {
    set_has_multi_plugin();
    _impl_.mesh_oneof_.multi_plugin_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.NodeStaticMesh.multi_plugin)
}
inline ::frame::proto::MultiPlugin* NodeStaticMesh::_internal_mutable_multi_plugin() {
  if (mesh_oneof_case() != kMultiPlugin) {
    clear_mesh_oneof();
    set_has_multi_plugin();
    _impl_.mesh_oneof_.multi_plugin_ =
        ::google::protobuf::Message::DefaultConstruct<::frame::proto::MultiPlugin>(GetArena());
  }
  return _impl_.mesh_oneof_.multi_plugin_;
}
inline ::frame::proto::MultiPlugin* NodeStaticMesh::mutable_multi_plugin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::MultiPlugin* _msg = _internal_mutable_multi_plugin();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeStaticMesh.multi_plugin)
  return _msg;
}

// string material_name = 5;
inline void NodeStaticMesh::clear_material_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.material_name_.ClearToEmpty();
}
inline const std::string& NodeStaticMesh::material_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeStaticMesh.material_name)
  return _internal_material_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeStaticMesh::set_material_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.material_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeStaticMesh.material_name)
}
inline std::string* NodeStaticMesh::mutable_material_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_material_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeStaticMesh.material_name)
  return _s;
}
inline const std::string& NodeStaticMesh::_internal_material_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.material_name_.Get();
}
inline void NodeStaticMesh::_internal_set_material_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.material_name_.Set(value, GetArena());
}
inline std::string* NodeStaticMesh::_internal_mutable_material_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.material_name_.Mutable( GetArena());
}
inline std::string* NodeStaticMesh::release_material_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeStaticMesh.material_name)
  return _impl_.material_name_.Release();
}
inline void NodeStaticMesh::set_allocated_material_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.material_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.material_name_.IsDefault()) {
    _impl_.material_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeStaticMesh.material_name)
}

// .frame.proto.NodeStaticMesh.RenderTimeEnum render_time_enum = 11;
inline void NodeStaticMesh::clear_render_time_enum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.render_time_enum_ = 0;
}
inline ::frame::proto::NodeStaticMesh_RenderTimeEnum NodeStaticMesh::render_time_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeStaticMesh.render_time_enum)
  return _internal_render_time_enum();
}
inline void NodeStaticMesh::set_render_time_enum(::frame::proto::NodeStaticMesh_RenderTimeEnum value) {
  _internal_set_render_time_enum(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeStaticMesh.render_time_enum)
}
inline ::frame::proto::NodeStaticMesh_RenderTimeEnum NodeStaticMesh::_internal_render_time_enum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::frame::proto::NodeStaticMesh_RenderTimeEnum>(_impl_.render_time_enum_);
}
inline void NodeStaticMesh::_internal_set_render_time_enum(::frame::proto::NodeStaticMesh_RenderTimeEnum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.render_time_enum_ = value;
}

// .frame.proto.NodeStaticMesh.ShadowEffectEnum shadow_effect_enum = 12;
inline void NodeStaticMesh::clear_shadow_effect_enum() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shadow_effect_enum_ = 0;
}
inline ::frame::proto::NodeStaticMesh_ShadowEffectEnum NodeStaticMesh::shadow_effect_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeStaticMesh.shadow_effect_enum)
  return _internal_shadow_effect_enum();
}
inline void NodeStaticMesh::set_shadow_effect_enum(::frame::proto::NodeStaticMesh_ShadowEffectEnum value) {
  _internal_set_shadow_effect_enum(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeStaticMesh.shadow_effect_enum)
}
inline ::frame::proto::NodeStaticMesh_ShadowEffectEnum NodeStaticMesh::_internal_shadow_effect_enum() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::frame::proto::NodeStaticMesh_ShadowEffectEnum>(_impl_.shadow_effect_enum_);
}
inline void NodeStaticMesh::_internal_set_shadow_effect_enum(::frame::proto::NodeStaticMesh_ShadowEffectEnum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shadow_effect_enum_ = value;
}

inline bool NodeStaticMesh::has_mesh_oneof() const {
  return mesh_oneof_case() != MESH_ONEOF_NOT_SET;
}
inline void NodeStaticMesh::clear_has_mesh_oneof() {
  _impl_._oneof_case_[0] = MESH_ONEOF_NOT_SET;
}
inline NodeStaticMesh::MeshOneofCase NodeStaticMesh::mesh_oneof_case() const {
  return NodeStaticMesh::MeshOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// NodeCamera

// string name = 1;
inline void NodeCamera::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeCamera::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeCamera.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeCamera::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeCamera.name)
}
inline std::string* NodeCamera::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeCamera.name)
  return _s;
}
inline const std::string& NodeCamera::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void NodeCamera::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NodeCamera::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NodeCamera::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeCamera.name)
  return _impl_.name_.Release();
}
inline void NodeCamera::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeCamera.name)
}

// string parent = 2;
inline void NodeCamera::clear_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& NodeCamera::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeCamera.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeCamera::set_parent(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeCamera.parent)
}
inline std::string* NodeCamera::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeCamera.parent)
  return _s;
}
inline const std::string& NodeCamera::_internal_parent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_.Get();
}
inline void NodeCamera::_internal_set_parent(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* NodeCamera::_internal_mutable_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* NodeCamera::release_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeCamera.parent)
  return _impl_.parent_.Release();
}
inline void NodeCamera::set_allocated_parent(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeCamera.parent)
}

// .frame.proto.UniformVector3 position = 3;
inline bool NodeCamera::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& NodeCamera::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::frame::proto::UniformVector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& NodeCamera::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeCamera.position)
  return _internal_position();
}
inline void NodeCamera::unsafe_arena_set_allocated_position(::frame::proto::UniformVector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.NodeCamera.position)
}
inline ::frame::proto::UniformVector3* NodeCamera::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::frame::proto::UniformVector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::frame::proto::UniformVector3* NodeCamera::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeCamera.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::frame::proto::UniformVector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* NodeCamera::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::frame::proto::UniformVector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.position_;
}
inline ::frame::proto::UniformVector3* NodeCamera::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::frame::proto::UniformVector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeCamera.position)
  return _msg;
}
inline void NodeCamera::set_allocated_position(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeCamera.position)
}

// .frame.proto.UniformVector3 target = 4;
inline bool NodeCamera::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& NodeCamera::_internal_target() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::frame::proto::UniformVector3* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& NodeCamera::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeCamera.target)
  return _internal_target();
}
inline void NodeCamera::unsafe_arena_set_allocated_target(::frame::proto::UniformVector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.NodeCamera.target)
}
inline ::frame::proto::UniformVector3* NodeCamera::release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::frame::proto::UniformVector3* released = _impl_.target_;
  _impl_.target_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::frame::proto::UniformVector3* NodeCamera::unsafe_arena_release_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeCamera.target)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::frame::proto::UniformVector3* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* NodeCamera::_internal_mutable_target() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.target_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::frame::proto::UniformVector3>(GetArena());
    _impl_.target_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.target_;
}
inline ::frame::proto::UniformVector3* NodeCamera::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::frame::proto::UniformVector3* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeCamera.target)
  return _msg;
}
inline void NodeCamera::set_allocated_target(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.target_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeCamera.target)
}

// .frame.proto.UniformVector3 up = 5;
inline bool NodeCamera::has_up() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.up_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& NodeCamera::_internal_up() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::frame::proto::UniformVector3* p = _impl_.up_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& NodeCamera::up() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeCamera.up)
  return _internal_up();
}
inline void NodeCamera::unsafe_arena_set_allocated_up(::frame::proto::UniformVector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.up_);
  }
  _impl_.up_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.NodeCamera.up)
}
inline ::frame::proto::UniformVector3* NodeCamera::release_up() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::frame::proto::UniformVector3* released = _impl_.up_;
  _impl_.up_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::frame::proto::UniformVector3* NodeCamera::unsafe_arena_release_up() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeCamera.up)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::frame::proto::UniformVector3* temp = _impl_.up_;
  _impl_.up_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* NodeCamera::_internal_mutable_up() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.up_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::frame::proto::UniformVector3>(GetArena());
    _impl_.up_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.up_;
}
inline ::frame::proto::UniformVector3* NodeCamera::mutable_up() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::frame::proto::UniformVector3* _msg = _internal_mutable_up();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeCamera.up)
  return _msg;
}
inline void NodeCamera::set_allocated_up(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.up_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.up_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeCamera.up)
}

// float fov_degrees = 6;
inline void NodeCamera::clear_fov_degrees() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fov_degrees_ = 0;
}
inline float NodeCamera::fov_degrees() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeCamera.fov_degrees)
  return _internal_fov_degrees();
}
inline void NodeCamera::set_fov_degrees(float value) {
  _internal_set_fov_degrees(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeCamera.fov_degrees)
}
inline float NodeCamera::_internal_fov_degrees() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.fov_degrees_;
}
inline void NodeCamera::_internal_set_fov_degrees(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.fov_degrees_ = value;
}

// float aspect_ratio = 7;
inline void NodeCamera::clear_aspect_ratio() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aspect_ratio_ = 0;
}
inline float NodeCamera::aspect_ratio() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeCamera.aspect_ratio)
  return _internal_aspect_ratio();
}
inline void NodeCamera::set_aspect_ratio(float value) {
  _internal_set_aspect_ratio(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeCamera.aspect_ratio)
}
inline float NodeCamera::_internal_aspect_ratio() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.aspect_ratio_;
}
inline void NodeCamera::_internal_set_aspect_ratio(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.aspect_ratio_ = value;
}

// float near_clip = 8;
inline void NodeCamera::clear_near_clip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.near_clip_ = 0;
}
inline float NodeCamera::near_clip() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeCamera.near_clip)
  return _internal_near_clip();
}
inline void NodeCamera::set_near_clip(float value) {
  _internal_set_near_clip(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeCamera.near_clip)
}
inline float NodeCamera::_internal_near_clip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.near_clip_;
}
inline void NodeCamera::_internal_set_near_clip(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.near_clip_ = value;
}

// float far_clip = 9;
inline void NodeCamera::clear_far_clip() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.far_clip_ = 0;
}
inline float NodeCamera::far_clip() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeCamera.far_clip)
  return _internal_far_clip();
}
inline void NodeCamera::set_far_clip(float value) {
  _internal_set_far_clip(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeCamera.far_clip)
}
inline float NodeCamera::_internal_far_clip() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.far_clip_;
}
inline void NodeCamera::_internal_set_far_clip(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.far_clip_ = value;
}

// -------------------------------------------------------------------

// NodeLight

// string name = 1;
inline void NodeLight::clear_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& NodeLight::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeLight.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeLight::set_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeLight.name)
}
inline std::string* NodeLight::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeLight.name)
  return _s;
}
inline const std::string& NodeLight::_internal_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.name_.Get();
}
inline void NodeLight::_internal_set_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.Set(value, GetArena());
}
inline std::string* NodeLight::_internal_mutable_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* NodeLight::release_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeLight.name)
  return _impl_.name_.Release();
}
inline void NodeLight::set_allocated_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeLight.name)
}

// string parent = 2;
inline void NodeLight::clear_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& NodeLight::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeLight.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeLight::set_parent(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeLight.parent)
}
inline std::string* NodeLight::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeLight.parent)
  return _s;
}
inline const std::string& NodeLight::_internal_parent() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.parent_.Get();
}
inline void NodeLight::_internal_set_parent(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* NodeLight::_internal_mutable_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* NodeLight::release_parent() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeLight.parent)
  return _impl_.parent_.Release();
}
inline void NodeLight::set_allocated_parent(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.parent_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeLight.parent)
}

// .frame.proto.NodeLight.LightTypeEnum light_type = 3;
inline void NodeLight::clear_light_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.light_type_ = 0;
}
inline ::frame::proto::NodeLight_LightTypeEnum NodeLight::light_type() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeLight.light_type)
  return _internal_light_type();
}
inline void NodeLight::set_light_type(::frame::proto::NodeLight_LightTypeEnum value) {
  _internal_set_light_type(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeLight.light_type)
}
inline ::frame::proto::NodeLight_LightTypeEnum NodeLight::_internal_light_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::frame::proto::NodeLight_LightTypeEnum>(_impl_.light_type_);
}
inline void NodeLight::_internal_set_light_type(::frame::proto::NodeLight_LightTypeEnum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.light_type_ = value;
}

// .frame.proto.UniformVector3 position = 4;
inline bool NodeLight::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& NodeLight::_internal_position() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::frame::proto::UniformVector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& NodeLight::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeLight.position)
  return _internal_position();
}
inline void NodeLight::unsafe_arena_set_allocated_position(::frame::proto::UniformVector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.NodeLight.position)
}
inline ::frame::proto::UniformVector3* NodeLight::release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::frame::proto::UniformVector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::frame::proto::UniformVector3* NodeLight::unsafe_arena_release_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeLight.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::frame::proto::UniformVector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* NodeLight::_internal_mutable_position() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.position_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::frame::proto::UniformVector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.position_;
}
inline ::frame::proto::UniformVector3* NodeLight::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000001u;
  ::frame::proto::UniformVector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeLight.position)
  return _msg;
}
inline void NodeLight::set_allocated_position(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeLight.position)
}

// .frame.proto.UniformVector3 direction = 5;
inline bool NodeLight::has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.direction_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& NodeLight::_internal_direction() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::frame::proto::UniformVector3* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& NodeLight::direction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeLight.direction)
  return _internal_direction();
}
inline void NodeLight::unsafe_arena_set_allocated_direction(::frame::proto::UniformVector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.NodeLight.direction)
}
inline ::frame::proto::UniformVector3* NodeLight::release_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::frame::proto::UniformVector3* released = _impl_.direction_;
  _impl_.direction_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::frame::proto::UniformVector3* NodeLight::unsafe_arena_release_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeLight.direction)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::frame::proto::UniformVector3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* NodeLight::_internal_mutable_direction() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.direction_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::frame::proto::UniformVector3>(GetArena());
    _impl_.direction_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.direction_;
}
inline ::frame::proto::UniformVector3* NodeLight::mutable_direction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000002u;
  ::frame::proto::UniformVector3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeLight.direction)
  return _msg;
}
inline void NodeLight::set_allocated_direction(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.direction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.direction_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeLight.direction)
}

// float dot_inner_limit = 6;
inline void NodeLight::clear_dot_inner_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dot_inner_limit_ = 0;
}
inline float NodeLight::dot_inner_limit() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeLight.dot_inner_limit)
  return _internal_dot_inner_limit();
}
inline void NodeLight::set_dot_inner_limit(float value) {
  _internal_set_dot_inner_limit(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeLight.dot_inner_limit)
}
inline float NodeLight::_internal_dot_inner_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dot_inner_limit_;
}
inline void NodeLight::_internal_set_dot_inner_limit(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dot_inner_limit_ = value;
}

// float dot_outer_limit = 7;
inline void NodeLight::clear_dot_outer_limit() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dot_outer_limit_ = 0;
}
inline float NodeLight::dot_outer_limit() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeLight.dot_outer_limit)
  return _internal_dot_outer_limit();
}
inline void NodeLight::set_dot_outer_limit(float value) {
  _internal_set_dot_outer_limit(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeLight.dot_outer_limit)
}
inline float NodeLight::_internal_dot_outer_limit() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.dot_outer_limit_;
}
inline void NodeLight::_internal_set_dot_outer_limit(float value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.dot_outer_limit_ = value;
}

// .frame.proto.UniformVector3 color = 8;
inline bool NodeLight::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& NodeLight::_internal_color() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  const ::frame::proto::UniformVector3* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& NodeLight::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeLight.color)
  return _internal_color();
}
inline void NodeLight::unsafe_arena_set_allocated_color(::frame::proto::UniformVector3* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.NodeLight.color)
}
inline ::frame::proto::UniformVector3* NodeLight::release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::frame::proto::UniformVector3* released = _impl_.color_;
  _impl_.color_ = nullptr;
  if (::google::protobuf::internal::DebugHardenForceCopyInRelease()) {
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if (GetArena() == nullptr) {
      delete old;
    }
  } else {
    if (GetArena() != nullptr) {
      released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
  }
  return released;
}
inline ::frame::proto::UniformVector3* NodeLight::unsafe_arena_release_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeLight.color)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::frame::proto::UniformVector3* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* NodeLight::_internal_mutable_color() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (_impl_.color_ == nullptr) {
    auto* p = ::google::protobuf::Message::DefaultConstruct<::frame::proto::UniformVector3>(GetArena());
    _impl_.color_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.color_;
}
inline ::frame::proto::UniformVector3* NodeLight::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  _impl_._has_bits_[0] |= 0x00000004u;
  ::frame::proto::UniformVector3* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeLight.color)
  return _msg;
}
inline void NodeLight::set_allocated_color(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  ::google::protobuf::internal::TSanWrite(&_impl_);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.color_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeLight.color)
}

// .frame.proto.NodeLight.ShadowTypeEnum shadow_type = 9;
inline void NodeLight::clear_shadow_type() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shadow_type_ = 0;
}
inline ::frame::proto::NodeLight_ShadowTypeEnum NodeLight::shadow_type() const {
  // @@protoc_insertion_point(field_get:frame.proto.NodeLight.shadow_type)
  return _internal_shadow_type();
}
inline void NodeLight::set_shadow_type(::frame::proto::NodeLight_ShadowTypeEnum value) {
  _internal_set_shadow_type(value);
  // @@protoc_insertion_point(field_set:frame.proto.NodeLight.shadow_type)
}
inline ::frame::proto::NodeLight_ShadowTypeEnum NodeLight::_internal_shadow_type() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return static_cast<::frame::proto::NodeLight_ShadowTypeEnum>(_impl_.shadow_type_);
}
inline void NodeLight::_internal_set_shadow_type(::frame::proto::NodeLight_ShadowTypeEnum value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shadow_type_ = value;
}

// string shadow_texture = 10;
inline void NodeLight::clear_shadow_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shadow_texture_.ClearToEmpty();
}
inline const std::string& NodeLight::shadow_texture() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.NodeLight.shadow_texture)
  return _internal_shadow_texture();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void NodeLight::set_shadow_texture(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shadow_texture_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.NodeLight.shadow_texture)
}
inline std::string* NodeLight::mutable_shadow_texture() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shadow_texture();
  // @@protoc_insertion_point(field_mutable:frame.proto.NodeLight.shadow_texture)
  return _s;
}
inline const std::string& NodeLight::_internal_shadow_texture() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.shadow_texture_.Get();
}
inline void NodeLight::_internal_set_shadow_texture(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shadow_texture_.Set(value, GetArena());
}
inline std::string* NodeLight::_internal_mutable_shadow_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.shadow_texture_.Mutable( GetArena());
}
inline std::string* NodeLight::release_shadow_texture() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.NodeLight.shadow_texture)
  return _impl_.shadow_texture_.Release();
}
inline void NodeLight::set_allocated_shadow_texture(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.shadow_texture_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.shadow_texture_.IsDefault()) {
    _impl_.shadow_texture_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.NodeLight.shadow_texture)
}

// -------------------------------------------------------------------

// SceneTree

// string default_root_name = 1;
inline void SceneTree::clear_default_root_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_root_name_.ClearToEmpty();
}
inline const std::string& SceneTree::default_root_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.default_root_name)
  return _internal_default_root_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneTree::set_default_root_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_root_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneTree.default_root_name)
}
inline std::string* SceneTree::mutable_default_root_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_default_root_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.default_root_name)
  return _s;
}
inline const std::string& SceneTree::_internal_default_root_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.default_root_name_.Get();
}
inline void SceneTree::_internal_set_default_root_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_root_name_.Set(value, GetArena());
}
inline std::string* SceneTree::_internal_mutable_default_root_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.default_root_name_.Mutable( GetArena());
}
inline std::string* SceneTree::release_default_root_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.SceneTree.default_root_name)
  return _impl_.default_root_name_.Release();
}
inline void SceneTree::set_allocated_default_root_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_root_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.default_root_name_.IsDefault()) {
    _impl_.default_root_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneTree.default_root_name)
}

// string default_camera_name = 2;
inline void SceneTree::clear_default_camera_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_camera_name_.ClearToEmpty();
}
inline const std::string& SceneTree::default_camera_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.default_camera_name)
  return _internal_default_camera_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneTree::set_default_camera_name(Arg_&& arg,
                                                     Args_... args) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_camera_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneTree.default_camera_name)
}
inline std::string* SceneTree::mutable_default_camera_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_default_camera_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.default_camera_name)
  return _s;
}
inline const std::string& SceneTree::_internal_default_camera_name() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.default_camera_name_.Get();
}
inline void SceneTree::_internal_set_default_camera_name(const std::string& value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_camera_name_.Set(value, GetArena());
}
inline std::string* SceneTree::_internal_mutable_default_camera_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _impl_.default_camera_name_.Mutable( GetArena());
}
inline std::string* SceneTree::release_default_camera_name() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  // @@protoc_insertion_point(field_release:frame.proto.SceneTree.default_camera_name)
  return _impl_.default_camera_name_.Release();
}
inline void SceneTree::set_allocated_default_camera_name(std::string* value) {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.default_camera_name_.SetAllocated(value, GetArena());
  if (::google::protobuf::internal::DebugHardenForceCopyDefaultString() && _impl_.default_camera_name_.IsDefault()) {
    _impl_.default_camera_name_.Set("", GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneTree.default_camera_name)
}

// repeated .frame.proto.NodeMatrix node_matrices = 3;
inline int SceneTree::_internal_node_matrices_size() const {
  return _internal_node_matrices().size();
}
inline int SceneTree::node_matrices_size() const {
  return _internal_node_matrices_size();
}
inline void SceneTree::clear_node_matrices() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_matrices_.Clear();
}
inline ::frame::proto::NodeMatrix* SceneTree::mutable_node_matrices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.node_matrices)
  return _internal_mutable_node_matrices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::NodeMatrix>* SceneTree::mutable_node_matrices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.node_matrices)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_node_matrices();
}
inline const ::frame::proto::NodeMatrix& SceneTree::node_matrices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.node_matrices)
  return _internal_node_matrices().Get(index);
}
inline ::frame::proto::NodeMatrix* SceneTree::add_node_matrices() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::frame::proto::NodeMatrix* _add = _internal_mutable_node_matrices()->Add();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.node_matrices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeMatrix>& SceneTree::node_matrices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.node_matrices)
  return _internal_node_matrices();
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeMatrix>&
SceneTree::_internal_node_matrices() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_matrices_;
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::NodeMatrix>*
SceneTree::_internal_mutable_node_matrices() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.node_matrices_;
}

// repeated .frame.proto.NodeStaticMesh node_static_meshes = 4;
inline int SceneTree::_internal_node_static_meshes_size() const {
  return _internal_node_static_meshes().size();
}
inline int SceneTree::node_static_meshes_size() const {
  return _internal_node_static_meshes_size();
}
inline void SceneTree::clear_node_static_meshes() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_static_meshes_.Clear();
}
inline ::frame::proto::NodeStaticMesh* SceneTree::mutable_node_static_meshes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.node_static_meshes)
  return _internal_mutable_node_static_meshes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::NodeStaticMesh>* SceneTree::mutable_node_static_meshes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.node_static_meshes)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_node_static_meshes();
}
inline const ::frame::proto::NodeStaticMesh& SceneTree::node_static_meshes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.node_static_meshes)
  return _internal_node_static_meshes().Get(index);
}
inline ::frame::proto::NodeStaticMesh* SceneTree::add_node_static_meshes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::frame::proto::NodeStaticMesh* _add = _internal_mutable_node_static_meshes()->Add();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.node_static_meshes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeStaticMesh>& SceneTree::node_static_meshes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.node_static_meshes)
  return _internal_node_static_meshes();
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeStaticMesh>&
SceneTree::_internal_node_static_meshes() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_static_meshes_;
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::NodeStaticMesh>*
SceneTree::_internal_mutable_node_static_meshes() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.node_static_meshes_;
}

// repeated .frame.proto.NodeCamera node_cameras = 5;
inline int SceneTree::_internal_node_cameras_size() const {
  return _internal_node_cameras().size();
}
inline int SceneTree::node_cameras_size() const {
  return _internal_node_cameras_size();
}
inline void SceneTree::clear_node_cameras() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_cameras_.Clear();
}
inline ::frame::proto::NodeCamera* SceneTree::mutable_node_cameras(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.node_cameras)
  return _internal_mutable_node_cameras()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::NodeCamera>* SceneTree::mutable_node_cameras()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.node_cameras)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_node_cameras();
}
inline const ::frame::proto::NodeCamera& SceneTree::node_cameras(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.node_cameras)
  return _internal_node_cameras().Get(index);
}
inline ::frame::proto::NodeCamera* SceneTree::add_node_cameras() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::frame::proto::NodeCamera* _add = _internal_mutable_node_cameras()->Add();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.node_cameras)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeCamera>& SceneTree::node_cameras() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.node_cameras)
  return _internal_node_cameras();
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeCamera>&
SceneTree::_internal_node_cameras() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_cameras_;
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::NodeCamera>*
SceneTree::_internal_mutable_node_cameras() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.node_cameras_;
}

// repeated .frame.proto.NodeLight node_lights = 6;
inline int SceneTree::_internal_node_lights_size() const {
  return _internal_node_lights().size();
}
inline int SceneTree::node_lights_size() const {
  return _internal_node_lights_size();
}
inline void SceneTree::clear_node_lights() {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  _impl_.node_lights_.Clear();
}
inline ::frame::proto::NodeLight* SceneTree::mutable_node_lights(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.node_lights)
  return _internal_mutable_node_lights()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::NodeLight>* SceneTree::mutable_node_lights()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.node_lights)
  ::google::protobuf::internal::TSanWrite(&_impl_);
  return _internal_mutable_node_lights();
}
inline const ::frame::proto::NodeLight& SceneTree::node_lights(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.node_lights)
  return _internal_node_lights().Get(index);
}
inline ::frame::proto::NodeLight* SceneTree::add_node_lights() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::google::protobuf::internal::TSanWrite(&_impl_);
  ::frame::proto::NodeLight* _add = _internal_mutable_node_lights()->Add();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.node_lights)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeLight>& SceneTree::node_lights() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.node_lights)
  return _internal_node_lights();
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::NodeLight>&
SceneTree::_internal_node_lights() const {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return _impl_.node_lights_;
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::NodeLight>*
SceneTree::_internal_mutable_node_lights() {
  ::google::protobuf::internal::TSanRead(&_impl_);
  return &_impl_.node_lights_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace frame


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::frame::proto::NodeMatrix_MatrixTypeEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::NodeMatrix_MatrixTypeEnum>() {
  return ::frame::proto::NodeMatrix_MatrixTypeEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::NodeStaticMesh_RenderPrimitiveEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::NodeStaticMesh_RenderPrimitiveEnum>() {
  return ::frame::proto::NodeStaticMesh_RenderPrimitiveEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::NodeStaticMesh_MeshEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::NodeStaticMesh_MeshEnum>() {
  return ::frame::proto::NodeStaticMesh_MeshEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::NodeStaticMesh_RenderTimeEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::NodeStaticMesh_RenderTimeEnum>() {
  return ::frame::proto::NodeStaticMesh_RenderTimeEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::NodeStaticMesh_ShadowEffectEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::NodeStaticMesh_ShadowEffectEnum>() {
  return ::frame::proto::NodeStaticMesh_ShadowEffectEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::NodeLight_LightTypeEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::NodeLight_LightTypeEnum>() {
  return ::frame::proto::NodeLight_LightTypeEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::NodeLight_ShadowTypeEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::NodeLight_ShadowTypeEnum>() {
  return ::frame::proto::NodeLight_ShadowTypeEnum_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // scene_2eproto_2epb_2eh
