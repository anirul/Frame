// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scene.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_scene_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_scene_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021008 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "pixel.pb.h"
#include "math.pb.h"
#include "stream.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_scene_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_scene_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_scene_2eproto;
namespace frame {
namespace proto {
class SceneCamera;
struct SceneCameraDefaultTypeInternal;
extern SceneCameraDefaultTypeInternal _SceneCamera_default_instance_;
class SceneLight;
struct SceneLightDefaultTypeInternal;
extern SceneLightDefaultTypeInternal _SceneLight_default_instance_;
class SceneMatrix;
struct SceneMatrixDefaultTypeInternal;
extern SceneMatrixDefaultTypeInternal _SceneMatrix_default_instance_;
class SceneStaticMesh;
struct SceneStaticMeshDefaultTypeInternal;
extern SceneStaticMeshDefaultTypeInternal _SceneStaticMesh_default_instance_;
class SceneTree;
struct SceneTreeDefaultTypeInternal;
extern SceneTreeDefaultTypeInternal _SceneTree_default_instance_;
}  // namespace proto
}  // namespace frame
PROTOBUF_NAMESPACE_OPEN
template<> ::frame::proto::SceneCamera* Arena::CreateMaybeMessage<::frame::proto::SceneCamera>(Arena*);
template<> ::frame::proto::SceneLight* Arena::CreateMaybeMessage<::frame::proto::SceneLight>(Arena*);
template<> ::frame::proto::SceneMatrix* Arena::CreateMaybeMessage<::frame::proto::SceneMatrix>(Arena*);
template<> ::frame::proto::SceneStaticMesh* Arena::CreateMaybeMessage<::frame::proto::SceneStaticMesh>(Arena*);
template<> ::frame::proto::SceneTree* Arena::CreateMaybeMessage<::frame::proto::SceneTree>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace frame {
namespace proto {

enum SceneStaticMesh_RenderPrimitiveEnum : int {
  SceneStaticMesh_RenderPrimitiveEnum_TRIANGLE = 0,
  SceneStaticMesh_RenderPrimitiveEnum_POINT = 1,
  SceneStaticMesh_RenderPrimitiveEnum_LINE = 2,
  SceneStaticMesh_RenderPrimitiveEnum_SceneStaticMesh_RenderPrimitiveEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SceneStaticMesh_RenderPrimitiveEnum_SceneStaticMesh_RenderPrimitiveEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SceneStaticMesh_RenderPrimitiveEnum_IsValid(int value);
constexpr SceneStaticMesh_RenderPrimitiveEnum SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MIN = SceneStaticMesh_RenderPrimitiveEnum_TRIANGLE;
constexpr SceneStaticMesh_RenderPrimitiveEnum SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MAX = SceneStaticMesh_RenderPrimitiveEnum_LINE;
constexpr int SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_ARRAYSIZE = SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SceneStaticMesh_RenderPrimitiveEnum_descriptor();
template<typename T>
inline const std::string& SceneStaticMesh_RenderPrimitiveEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SceneStaticMesh_RenderPrimitiveEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SceneStaticMesh_RenderPrimitiveEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SceneStaticMesh_RenderPrimitiveEnum_descriptor(), enum_t_value);
}
inline bool SceneStaticMesh_RenderPrimitiveEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SceneStaticMesh_RenderPrimitiveEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SceneStaticMesh_RenderPrimitiveEnum>(
    SceneStaticMesh_RenderPrimitiveEnum_descriptor(), name, value);
}
enum SceneStaticMesh_MeshEnum : int {
  SceneStaticMesh_MeshEnum_INVALID = 0,
  SceneStaticMesh_MeshEnum_CUBE = 1,
  SceneStaticMesh_MeshEnum_QUAD = 2,
  SceneStaticMesh_MeshEnum_SceneStaticMesh_MeshEnum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SceneStaticMesh_MeshEnum_SceneStaticMesh_MeshEnum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SceneStaticMesh_MeshEnum_IsValid(int value);
constexpr SceneStaticMesh_MeshEnum SceneStaticMesh_MeshEnum_MeshEnum_MIN = SceneStaticMesh_MeshEnum_INVALID;
constexpr SceneStaticMesh_MeshEnum SceneStaticMesh_MeshEnum_MeshEnum_MAX = SceneStaticMesh_MeshEnum_QUAD;
constexpr int SceneStaticMesh_MeshEnum_MeshEnum_ARRAYSIZE = SceneStaticMesh_MeshEnum_MeshEnum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SceneStaticMesh_MeshEnum_descriptor();
template<typename T>
inline const std::string& SceneStaticMesh_MeshEnum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SceneStaticMesh_MeshEnum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SceneStaticMesh_MeshEnum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SceneStaticMesh_MeshEnum_descriptor(), enum_t_value);
}
inline bool SceneStaticMesh_MeshEnum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SceneStaticMesh_MeshEnum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SceneStaticMesh_MeshEnum>(
    SceneStaticMesh_MeshEnum_descriptor(), name, value);
}
enum SceneLight_Enum : int {
  SceneLight_Enum_INVALID = 0,
  SceneLight_Enum_AMBIENT = 1,
  SceneLight_Enum_POINT = 2,
  SceneLight_Enum_DIRECTIONAL = 3,
  SceneLight_Enum_SPOT = 4,
  SceneLight_Enum_SceneLight_Enum_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  SceneLight_Enum_SceneLight_Enum_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool SceneLight_Enum_IsValid(int value);
constexpr SceneLight_Enum SceneLight_Enum_Enum_MIN = SceneLight_Enum_INVALID;
constexpr SceneLight_Enum SceneLight_Enum_Enum_MAX = SceneLight_Enum_SPOT;
constexpr int SceneLight_Enum_Enum_ARRAYSIZE = SceneLight_Enum_Enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* SceneLight_Enum_descriptor();
template<typename T>
inline const std::string& SceneLight_Enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, SceneLight_Enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function SceneLight_Enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    SceneLight_Enum_descriptor(), enum_t_value);
}
inline bool SceneLight_Enum_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, SceneLight_Enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<SceneLight_Enum>(
    SceneLight_Enum_descriptor(), name, value);
}
// ===================================================================

class SceneMatrix final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frame.proto.SceneMatrix) */ {
 public:
  inline SceneMatrix() : SceneMatrix(nullptr) {}
  ~SceneMatrix() override;
  explicit PROTOBUF_CONSTEXPR SceneMatrix(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SceneMatrix(const SceneMatrix& from);
  SceneMatrix(SceneMatrix&& from) noexcept
    : SceneMatrix() {
    *this = ::std::move(from);
  }

  inline SceneMatrix& operator=(const SceneMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneMatrix& operator=(SceneMatrix&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneMatrix& default_instance() {
    return *internal_default_instance();
  }
  static inline const SceneMatrix* internal_default_instance() {
    return reinterpret_cast<const SceneMatrix*>(
               &_SceneMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SceneMatrix& a, SceneMatrix& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneMatrix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneMatrix* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneMatrix* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SceneMatrix>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SceneMatrix& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SceneMatrix& from) {
    SceneMatrix::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SceneMatrix* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frame.proto.SceneMatrix";
  }
  protected:
  explicit SceneMatrix(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kMatrixFieldNumber = 3,
    kQuaternionFieldNumber = 4,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string parent = 2;
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // .frame.proto.UniformMatrix4 matrix = 3;
  bool has_matrix() const;
  private:
  bool _internal_has_matrix() const;
  public:
  void clear_matrix();
  const ::frame::proto::UniformMatrix4& matrix() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformMatrix4* release_matrix();
  ::frame::proto::UniformMatrix4* mutable_matrix();
  void set_allocated_matrix(::frame::proto::UniformMatrix4* matrix);
  private:
  const ::frame::proto::UniformMatrix4& _internal_matrix() const;
  ::frame::proto::UniformMatrix4* _internal_mutable_matrix();
  public:
  void unsafe_arena_set_allocated_matrix(
      ::frame::proto::UniformMatrix4* matrix);
  ::frame::proto::UniformMatrix4* unsafe_arena_release_matrix();

  // .frame.proto.UniformQuaternion quaternion = 4;
  bool has_quaternion() const;
  private:
  bool _internal_has_quaternion() const;
  public:
  void clear_quaternion();
  const ::frame::proto::UniformQuaternion& quaternion() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformQuaternion* release_quaternion();
  ::frame::proto::UniformQuaternion* mutable_quaternion();
  void set_allocated_quaternion(::frame::proto::UniformQuaternion* quaternion);
  private:
  const ::frame::proto::UniformQuaternion& _internal_quaternion() const;
  ::frame::proto::UniformQuaternion* _internal_mutable_quaternion();
  public:
  void unsafe_arena_set_allocated_quaternion(
      ::frame::proto::UniformQuaternion* quaternion);
  ::frame::proto::UniformQuaternion* unsafe_arena_release_quaternion();

  // @@protoc_insertion_point(class_scope:frame.proto.SceneMatrix)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::frame::proto::UniformMatrix4* matrix_;
    ::frame::proto::UniformQuaternion* quaternion_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class SceneStaticMesh final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frame.proto.SceneStaticMesh) */ {
 public:
  inline SceneStaticMesh() : SceneStaticMesh(nullptr) {}
  ~SceneStaticMesh() override;
  explicit PROTOBUF_CONSTEXPR SceneStaticMesh(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SceneStaticMesh(const SceneStaticMesh& from);
  SceneStaticMesh(SceneStaticMesh&& from) noexcept
    : SceneStaticMesh() {
    *this = ::std::move(from);
  }

  inline SceneStaticMesh& operator=(const SceneStaticMesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneStaticMesh& operator=(SceneStaticMesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneStaticMesh& default_instance() {
    return *internal_default_instance();
  }
  enum MeshOneofCase {
    kCleanBuffer = 7,
    kMeshEnum = 6,
    kFileName = 3,
    kStream = 10,
    MESH_ONEOF_NOT_SET = 0,
  };

  static inline const SceneStaticMesh* internal_default_instance() {
    return reinterpret_cast<const SceneStaticMesh*>(
               &_SceneStaticMesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SceneStaticMesh& a, SceneStaticMesh& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneStaticMesh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneStaticMesh* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneStaticMesh* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SceneStaticMesh>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SceneStaticMesh& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SceneStaticMesh& from) {
    SceneStaticMesh::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SceneStaticMesh* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frame.proto.SceneStaticMesh";
  }
  protected:
  explicit SceneStaticMesh(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SceneStaticMesh_RenderPrimitiveEnum RenderPrimitiveEnum;
  static constexpr RenderPrimitiveEnum TRIANGLE =
    SceneStaticMesh_RenderPrimitiveEnum_TRIANGLE;
  static constexpr RenderPrimitiveEnum POINT =
    SceneStaticMesh_RenderPrimitiveEnum_POINT;
  static constexpr RenderPrimitiveEnum LINE =
    SceneStaticMesh_RenderPrimitiveEnum_LINE;
  static inline bool RenderPrimitiveEnum_IsValid(int value) {
    return SceneStaticMesh_RenderPrimitiveEnum_IsValid(value);
  }
  static constexpr RenderPrimitiveEnum RenderPrimitiveEnum_MIN =
    SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MIN;
  static constexpr RenderPrimitiveEnum RenderPrimitiveEnum_MAX =
    SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MAX;
  static constexpr int RenderPrimitiveEnum_ARRAYSIZE =
    SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  RenderPrimitiveEnum_descriptor() {
    return SceneStaticMesh_RenderPrimitiveEnum_descriptor();
  }
  template<typename T>
  static inline const std::string& RenderPrimitiveEnum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, RenderPrimitiveEnum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function RenderPrimitiveEnum_Name.");
    return SceneStaticMesh_RenderPrimitiveEnum_Name(enum_t_value);
  }
  static inline bool RenderPrimitiveEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      RenderPrimitiveEnum* value) {
    return SceneStaticMesh_RenderPrimitiveEnum_Parse(name, value);
  }

  typedef SceneStaticMesh_MeshEnum MeshEnum;
  static constexpr MeshEnum INVALID =
    SceneStaticMesh_MeshEnum_INVALID;
  static constexpr MeshEnum CUBE =
    SceneStaticMesh_MeshEnum_CUBE;
  static constexpr MeshEnum QUAD =
    SceneStaticMesh_MeshEnum_QUAD;
  static inline bool MeshEnum_IsValid(int value) {
    return SceneStaticMesh_MeshEnum_IsValid(value);
  }
  static constexpr MeshEnum MeshEnum_MIN =
    SceneStaticMesh_MeshEnum_MeshEnum_MIN;
  static constexpr MeshEnum MeshEnum_MAX =
    SceneStaticMesh_MeshEnum_MeshEnum_MAX;
  static constexpr int MeshEnum_ARRAYSIZE =
    SceneStaticMesh_MeshEnum_MeshEnum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  MeshEnum_descriptor() {
    return SceneStaticMesh_MeshEnum_descriptor();
  }
  template<typename T>
  static inline const std::string& MeshEnum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, MeshEnum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function MeshEnum_Name.");
    return SceneStaticMesh_MeshEnum_Name(enum_t_value);
  }
  static inline bool MeshEnum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      MeshEnum* value) {
    return SceneStaticMesh_MeshEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kMaterialNameFieldNumber = 5,
    kRenderPrimitiveEnumFieldNumber = 8,
    kCleanBufferFieldNumber = 7,
    kMeshEnumFieldNumber = 6,
    kFileNameFieldNumber = 3,
    kStreamFieldNumber = 10,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string parent = 2;
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // string material_name = 5;
  void clear_material_name();
  const std::string& material_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_material_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_material_name();
  PROTOBUF_NODISCARD std::string* release_material_name();
  void set_allocated_material_name(std::string* material_name);
  private:
  const std::string& _internal_material_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_material_name(const std::string& value);
  std::string* _internal_mutable_material_name();
  public:

  // .frame.proto.SceneStaticMesh.RenderPrimitiveEnum render_primitive_enum = 8;
  void clear_render_primitive_enum();
  ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum render_primitive_enum() const;
  void set_render_primitive_enum(::frame::proto::SceneStaticMesh_RenderPrimitiveEnum value);
  private:
  ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum _internal_render_primitive_enum() const;
  void _internal_set_render_primitive_enum(::frame::proto::SceneStaticMesh_RenderPrimitiveEnum value);
  public:

  // .frame.proto.CleanBuffer clean_buffer = 7;
  bool has_clean_buffer() const;
  private:
  bool _internal_has_clean_buffer() const;
  public:
  void clear_clean_buffer();
  const ::frame::proto::CleanBuffer& clean_buffer() const;
  PROTOBUF_NODISCARD ::frame::proto::CleanBuffer* release_clean_buffer();
  ::frame::proto::CleanBuffer* mutable_clean_buffer();
  void set_allocated_clean_buffer(::frame::proto::CleanBuffer* clean_buffer);
  private:
  const ::frame::proto::CleanBuffer& _internal_clean_buffer() const;
  ::frame::proto::CleanBuffer* _internal_mutable_clean_buffer();
  public:
  void unsafe_arena_set_allocated_clean_buffer(
      ::frame::proto::CleanBuffer* clean_buffer);
  ::frame::proto::CleanBuffer* unsafe_arena_release_clean_buffer();

  // .frame.proto.SceneStaticMesh.MeshEnum mesh_enum = 6;
  bool has_mesh_enum() const;
  private:
  bool _internal_has_mesh_enum() const;
  public:
  void clear_mesh_enum();
  ::frame::proto::SceneStaticMesh_MeshEnum mesh_enum() const;
  void set_mesh_enum(::frame::proto::SceneStaticMesh_MeshEnum value);
  private:
  ::frame::proto::SceneStaticMesh_MeshEnum _internal_mesh_enum() const;
  void _internal_set_mesh_enum(::frame::proto::SceneStaticMesh_MeshEnum value);
  public:

  // string file_name = 3;
  bool has_file_name() const;
  private:
  bool _internal_has_file_name() const;
  public:
  void clear_file_name();
  const std::string& file_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_file_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* file_name);
  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(const std::string& value);
  std::string* _internal_mutable_file_name();
  public:

  // .frame.proto.Stream stream = 10;
  bool has_stream() const;
  private:
  bool _internal_has_stream() const;
  public:
  void clear_stream();
  const ::frame::proto::Stream& stream() const;
  PROTOBUF_NODISCARD ::frame::proto::Stream* release_stream();
  ::frame::proto::Stream* mutable_stream();
  void set_allocated_stream(::frame::proto::Stream* stream);
  private:
  const ::frame::proto::Stream& _internal_stream() const;
  ::frame::proto::Stream* _internal_mutable_stream();
  public:
  void unsafe_arena_set_allocated_stream(
      ::frame::proto::Stream* stream);
  ::frame::proto::Stream* unsafe_arena_release_stream();

  void clear_mesh_oneof();
  MeshOneofCase mesh_oneof_case() const;
  // @@protoc_insertion_point(class_scope:frame.proto.SceneStaticMesh)
 private:
  class _Internal;
  void set_has_clean_buffer();
  void set_has_mesh_enum();
  void set_has_file_name();
  void set_has_stream();

  inline bool has_mesh_oneof() const;
  inline void clear_has_mesh_oneof();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr material_name_;
    int render_primitive_enum_;
    union MeshOneofUnion {
      constexpr MeshOneofUnion() : _constinit_{} {}
        ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
      ::frame::proto::CleanBuffer* clean_buffer_;
      int mesh_enum_;
      ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr file_name_;
      ::frame::proto::Stream* stream_;
    } mesh_oneof_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
    uint32_t _oneof_case_[1];

  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class SceneCamera final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frame.proto.SceneCamera) */ {
 public:
  inline SceneCamera() : SceneCamera(nullptr) {}
  ~SceneCamera() override;
  explicit PROTOBUF_CONSTEXPR SceneCamera(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SceneCamera(const SceneCamera& from);
  SceneCamera(SceneCamera&& from) noexcept
    : SceneCamera() {
    *this = ::std::move(from);
  }

  inline SceneCamera& operator=(const SceneCamera& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneCamera& operator=(SceneCamera&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneCamera& default_instance() {
    return *internal_default_instance();
  }
  static inline const SceneCamera* internal_default_instance() {
    return reinterpret_cast<const SceneCamera*>(
               &_SceneCamera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SceneCamera& a, SceneCamera& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneCamera* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneCamera* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneCamera* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SceneCamera>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SceneCamera& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SceneCamera& from) {
    SceneCamera::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SceneCamera* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frame.proto.SceneCamera";
  }
  protected:
  explicit SceneCamera(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kPositionFieldNumber = 3,
    kTargetFieldNumber = 4,
    kUpFieldNumber = 5,
    kFovDegreesFieldNumber = 6,
    kAspectRatioFieldNumber = 7,
    kNearClipFieldNumber = 8,
    kFarClipFieldNumber = 9,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string parent = 2;
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // .frame.proto.UniformVector3 position = 3;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::frame::proto::UniformVector3& position() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_position();
  ::frame::proto::UniformVector3* mutable_position();
  void set_allocated_position(::frame::proto::UniformVector3* position);
  private:
  const ::frame::proto::UniformVector3& _internal_position() const;
  ::frame::proto::UniformVector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::frame::proto::UniformVector3* position);
  ::frame::proto::UniformVector3* unsafe_arena_release_position();

  // .frame.proto.UniformVector3 target = 4;
  bool has_target() const;
  private:
  bool _internal_has_target() const;
  public:
  void clear_target();
  const ::frame::proto::UniformVector3& target() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_target();
  ::frame::proto::UniformVector3* mutable_target();
  void set_allocated_target(::frame::proto::UniformVector3* target);
  private:
  const ::frame::proto::UniformVector3& _internal_target() const;
  ::frame::proto::UniformVector3* _internal_mutable_target();
  public:
  void unsafe_arena_set_allocated_target(
      ::frame::proto::UniformVector3* target);
  ::frame::proto::UniformVector3* unsafe_arena_release_target();

  // .frame.proto.UniformVector3 up = 5;
  bool has_up() const;
  private:
  bool _internal_has_up() const;
  public:
  void clear_up();
  const ::frame::proto::UniformVector3& up() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_up();
  ::frame::proto::UniformVector3* mutable_up();
  void set_allocated_up(::frame::proto::UniformVector3* up);
  private:
  const ::frame::proto::UniformVector3& _internal_up() const;
  ::frame::proto::UniformVector3* _internal_mutable_up();
  public:
  void unsafe_arena_set_allocated_up(
      ::frame::proto::UniformVector3* up);
  ::frame::proto::UniformVector3* unsafe_arena_release_up();

  // float fov_degrees = 6;
  void clear_fov_degrees();
  float fov_degrees() const;
  void set_fov_degrees(float value);
  private:
  float _internal_fov_degrees() const;
  void _internal_set_fov_degrees(float value);
  public:

  // float aspect_ratio = 7;
  void clear_aspect_ratio();
  float aspect_ratio() const;
  void set_aspect_ratio(float value);
  private:
  float _internal_aspect_ratio() const;
  void _internal_set_aspect_ratio(float value);
  public:

  // float near_clip = 8;
  void clear_near_clip();
  float near_clip() const;
  void set_near_clip(float value);
  private:
  float _internal_near_clip() const;
  void _internal_set_near_clip(float value);
  public:

  // float far_clip = 9;
  void clear_far_clip();
  float far_clip() const;
  void set_far_clip(float value);
  private:
  float _internal_far_clip() const;
  void _internal_set_far_clip(float value);
  public:

  // @@protoc_insertion_point(class_scope:frame.proto.SceneCamera)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::frame::proto::UniformVector3* position_;
    ::frame::proto::UniformVector3* target_;
    ::frame::proto::UniformVector3* up_;
    float fov_degrees_;
    float aspect_ratio_;
    float near_clip_;
    float far_clip_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class SceneLight final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frame.proto.SceneLight) */ {
 public:
  inline SceneLight() : SceneLight(nullptr) {}
  ~SceneLight() override;
  explicit PROTOBUF_CONSTEXPR SceneLight(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SceneLight(const SceneLight& from);
  SceneLight(SceneLight&& from) noexcept
    : SceneLight() {
    *this = ::std::move(from);
  }

  inline SceneLight& operator=(const SceneLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneLight& operator=(SceneLight&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneLight& default_instance() {
    return *internal_default_instance();
  }
  static inline const SceneLight* internal_default_instance() {
    return reinterpret_cast<const SceneLight*>(
               &_SceneLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SceneLight& a, SceneLight& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneLight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneLight* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneLight* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SceneLight>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SceneLight& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SceneLight& from) {
    SceneLight::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SceneLight* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frame.proto.SceneLight";
  }
  protected:
  explicit SceneLight(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef SceneLight_Enum Enum;
  static constexpr Enum INVALID =
    SceneLight_Enum_INVALID;
  static constexpr Enum AMBIENT =
    SceneLight_Enum_AMBIENT;
  static constexpr Enum POINT =
    SceneLight_Enum_POINT;
  static constexpr Enum DIRECTIONAL =
    SceneLight_Enum_DIRECTIONAL;
  static constexpr Enum SPOT =
    SceneLight_Enum_SPOT;
  static inline bool Enum_IsValid(int value) {
    return SceneLight_Enum_IsValid(value);
  }
  static constexpr Enum Enum_MIN =
    SceneLight_Enum_Enum_MIN;
  static constexpr Enum Enum_MAX =
    SceneLight_Enum_Enum_MAX;
  static constexpr int Enum_ARRAYSIZE =
    SceneLight_Enum_Enum_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  Enum_descriptor() {
    return SceneLight_Enum_descriptor();
  }
  template<typename T>
  static inline const std::string& Enum_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Enum>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Enum_Name.");
    return SceneLight_Enum_Name(enum_t_value);
  }
  static inline bool Enum_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Enum* value) {
    return SceneLight_Enum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kPositionFieldNumber = 4,
    kDirectionFieldNumber = 5,
    kColorFieldNumber = 8,
    kLightTypeFieldNumber = 3,
    kDotInnerLimitFieldNumber = 6,
    kDotOuterLimitFieldNumber = 7,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string parent = 2;
  void clear_parent();
  const std::string& parent() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* parent);
  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(const std::string& value);
  std::string* _internal_mutable_parent();
  public:

  // .frame.proto.UniformVector3 position = 4;
  bool has_position() const;
  private:
  bool _internal_has_position() const;
  public:
  void clear_position();
  const ::frame::proto::UniformVector3& position() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_position();
  ::frame::proto::UniformVector3* mutable_position();
  void set_allocated_position(::frame::proto::UniformVector3* position);
  private:
  const ::frame::proto::UniformVector3& _internal_position() const;
  ::frame::proto::UniformVector3* _internal_mutable_position();
  public:
  void unsafe_arena_set_allocated_position(
      ::frame::proto::UniformVector3* position);
  ::frame::proto::UniformVector3* unsafe_arena_release_position();

  // .frame.proto.UniformVector3 direction = 5;
  bool has_direction() const;
  private:
  bool _internal_has_direction() const;
  public:
  void clear_direction();
  const ::frame::proto::UniformVector3& direction() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_direction();
  ::frame::proto::UniformVector3* mutable_direction();
  void set_allocated_direction(::frame::proto::UniformVector3* direction);
  private:
  const ::frame::proto::UniformVector3& _internal_direction() const;
  ::frame::proto::UniformVector3* _internal_mutable_direction();
  public:
  void unsafe_arena_set_allocated_direction(
      ::frame::proto::UniformVector3* direction);
  ::frame::proto::UniformVector3* unsafe_arena_release_direction();

  // .frame.proto.UniformVector3 color = 8;
  bool has_color() const;
  private:
  bool _internal_has_color() const;
  public:
  void clear_color();
  const ::frame::proto::UniformVector3& color() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_color();
  ::frame::proto::UniformVector3* mutable_color();
  void set_allocated_color(::frame::proto::UniformVector3* color);
  private:
  const ::frame::proto::UniformVector3& _internal_color() const;
  ::frame::proto::UniformVector3* _internal_mutable_color();
  public:
  void unsafe_arena_set_allocated_color(
      ::frame::proto::UniformVector3* color);
  ::frame::proto::UniformVector3* unsafe_arena_release_color();

  // .frame.proto.SceneLight.Enum light_type = 3;
  void clear_light_type();
  ::frame::proto::SceneLight_Enum light_type() const;
  void set_light_type(::frame::proto::SceneLight_Enum value);
  private:
  ::frame::proto::SceneLight_Enum _internal_light_type() const;
  void _internal_set_light_type(::frame::proto::SceneLight_Enum value);
  public:

  // float dot_inner_limit = 6;
  void clear_dot_inner_limit();
  float dot_inner_limit() const;
  void set_dot_inner_limit(float value);
  private:
  float _internal_dot_inner_limit() const;
  void _internal_set_dot_inner_limit(float value);
  public:

  // float dot_outer_limit = 7;
  void clear_dot_outer_limit();
  float dot_outer_limit() const;
  void set_dot_outer_limit(float value);
  private:
  float _internal_dot_outer_limit() const;
  void _internal_set_dot_outer_limit(float value);
  public:

  // @@protoc_insertion_point(class_scope:frame.proto.SceneLight)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_;
    ::frame::proto::UniformVector3* position_;
    ::frame::proto::UniformVector3* direction_;
    ::frame::proto::UniformVector3* color_;
    int light_type_;
    float dot_inner_limit_;
    float dot_outer_limit_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};
// -------------------------------------------------------------------

class SceneTree final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:frame.proto.SceneTree) */ {
 public:
  inline SceneTree() : SceneTree(nullptr) {}
  ~SceneTree() override;
  explicit PROTOBUF_CONSTEXPR SceneTree(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SceneTree(const SceneTree& from);
  SceneTree(SceneTree&& from) noexcept
    : SceneTree() {
    *this = ::std::move(from);
  }

  inline SceneTree& operator=(const SceneTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneTree& operator=(SceneTree&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const SceneTree* internal_default_instance() {
    return reinterpret_cast<const SceneTree*>(
               &_SceneTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SceneTree& a, SceneTree& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneTree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneTree* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneTree* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SceneTree>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SceneTree& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SceneTree& from) {
    SceneTree::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SceneTree* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "frame.proto.SceneTree";
  }
  protected:
  explicit SceneTree(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSceneMatricesFieldNumber = 3,
    kSceneStaticMeshesFieldNumber = 4,
    kSceneCamerasFieldNumber = 5,
    kSceneLightsFieldNumber = 6,
    kDefaultRootNameFieldNumber = 1,
    kDefaultCameraNameFieldNumber = 2,
  };
  // repeated .frame.proto.SceneMatrix scene_matrices = 3;
  int scene_matrices_size() const;
  private:
  int _internal_scene_matrices_size() const;
  public:
  void clear_scene_matrices();
  ::frame::proto::SceneMatrix* mutable_scene_matrices(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneMatrix >*
      mutable_scene_matrices();
  private:
  const ::frame::proto::SceneMatrix& _internal_scene_matrices(int index) const;
  ::frame::proto::SceneMatrix* _internal_add_scene_matrices();
  public:
  const ::frame::proto::SceneMatrix& scene_matrices(int index) const;
  ::frame::proto::SceneMatrix* add_scene_matrices();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneMatrix >&
      scene_matrices() const;

  // repeated .frame.proto.SceneStaticMesh scene_static_meshes = 4;
  int scene_static_meshes_size() const;
  private:
  int _internal_scene_static_meshes_size() const;
  public:
  void clear_scene_static_meshes();
  ::frame::proto::SceneStaticMesh* mutable_scene_static_meshes(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneStaticMesh >*
      mutable_scene_static_meshes();
  private:
  const ::frame::proto::SceneStaticMesh& _internal_scene_static_meshes(int index) const;
  ::frame::proto::SceneStaticMesh* _internal_add_scene_static_meshes();
  public:
  const ::frame::proto::SceneStaticMesh& scene_static_meshes(int index) const;
  ::frame::proto::SceneStaticMesh* add_scene_static_meshes();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneStaticMesh >&
      scene_static_meshes() const;

  // repeated .frame.proto.SceneCamera scene_cameras = 5;
  int scene_cameras_size() const;
  private:
  int _internal_scene_cameras_size() const;
  public:
  void clear_scene_cameras();
  ::frame::proto::SceneCamera* mutable_scene_cameras(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneCamera >*
      mutable_scene_cameras();
  private:
  const ::frame::proto::SceneCamera& _internal_scene_cameras(int index) const;
  ::frame::proto::SceneCamera* _internal_add_scene_cameras();
  public:
  const ::frame::proto::SceneCamera& scene_cameras(int index) const;
  ::frame::proto::SceneCamera* add_scene_cameras();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneCamera >&
      scene_cameras() const;

  // repeated .frame.proto.SceneLight scene_lights = 6;
  int scene_lights_size() const;
  private:
  int _internal_scene_lights_size() const;
  public:
  void clear_scene_lights();
  ::frame::proto::SceneLight* mutable_scene_lights(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneLight >*
      mutable_scene_lights();
  private:
  const ::frame::proto::SceneLight& _internal_scene_lights(int index) const;
  ::frame::proto::SceneLight* _internal_add_scene_lights();
  public:
  const ::frame::proto::SceneLight& scene_lights(int index) const;
  ::frame::proto::SceneLight* add_scene_lights();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneLight >&
      scene_lights() const;

  // string default_root_name = 1;
  void clear_default_root_name();
  const std::string& default_root_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_root_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_root_name();
  PROTOBUF_NODISCARD std::string* release_default_root_name();
  void set_allocated_default_root_name(std::string* default_root_name);
  private:
  const std::string& _internal_default_root_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_root_name(const std::string& value);
  std::string* _internal_mutable_default_root_name();
  public:

  // string default_camera_name = 2;
  void clear_default_camera_name();
  const std::string& default_camera_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_default_camera_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_default_camera_name();
  PROTOBUF_NODISCARD std::string* release_default_camera_name();
  void set_allocated_default_camera_name(std::string* default_camera_name);
  private:
  const std::string& _internal_default_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_camera_name(const std::string& value);
  std::string* _internal_mutable_default_camera_name();
  public:

  // @@protoc_insertion_point(class_scope:frame.proto.SceneTree)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneMatrix > scene_matrices_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneStaticMesh > scene_static_meshes_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneCamera > scene_cameras_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneLight > scene_lights_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_root_name_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr default_camera_name_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// SceneMatrix

// string name = 1;
inline void SceneMatrix::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SceneMatrix::name() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneMatrix.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneMatrix::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneMatrix.name)
}
inline std::string* SceneMatrix::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneMatrix.name)
  return _s;
}
inline const std::string& SceneMatrix::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SceneMatrix::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneMatrix::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneMatrix::release_name() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneMatrix.name)
  return _impl_.name_.Release();
}
inline void SceneMatrix::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneMatrix.name)
}

// string parent = 2;
inline void SceneMatrix::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& SceneMatrix::parent() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneMatrix.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneMatrix::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneMatrix.parent)
}
inline std::string* SceneMatrix::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneMatrix.parent)
  return _s;
}
inline const std::string& SceneMatrix::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void SceneMatrix::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneMatrix::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneMatrix::release_parent() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneMatrix.parent)
  return _impl_.parent_.Release();
}
inline void SceneMatrix::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneMatrix.parent)
}

// .frame.proto.UniformMatrix4 matrix = 3;
inline bool SceneMatrix::_internal_has_matrix() const {
  return this != internal_default_instance() && _impl_.matrix_ != nullptr;
}
inline bool SceneMatrix::has_matrix() const {
  return _internal_has_matrix();
}
inline const ::frame::proto::UniformMatrix4& SceneMatrix::_internal_matrix() const {
  const ::frame::proto::UniformMatrix4* p = _impl_.matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformMatrix4&>(
      ::frame::proto::_UniformMatrix4_default_instance_);
}
inline const ::frame::proto::UniformMatrix4& SceneMatrix::matrix() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneMatrix.matrix)
  return _internal_matrix();
}
inline void SceneMatrix::unsafe_arena_set_allocated_matrix(
    ::frame::proto::UniformMatrix4* matrix) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.matrix_);
  }
  _impl_.matrix_ = matrix;
  if (matrix) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneMatrix.matrix)
}
inline ::frame::proto::UniformMatrix4* SceneMatrix::release_matrix() {
  
  ::frame::proto::UniformMatrix4* temp = _impl_.matrix_;
  _impl_.matrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::frame::proto::UniformMatrix4* SceneMatrix::unsafe_arena_release_matrix() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneMatrix.matrix)
  
  ::frame::proto::UniformMatrix4* temp = _impl_.matrix_;
  _impl_.matrix_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformMatrix4* SceneMatrix::_internal_mutable_matrix() {
  
  if (_impl_.matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformMatrix4>(GetArenaForAllocation());
    _impl_.matrix_ = p;
  }
  return _impl_.matrix_;
}
inline ::frame::proto::UniformMatrix4* SceneMatrix::mutable_matrix() {
  ::frame::proto::UniformMatrix4* _msg = _internal_mutable_matrix();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneMatrix.matrix)
  return _msg;
}
inline void SceneMatrix::set_allocated_matrix(::frame::proto::UniformMatrix4* matrix) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.matrix_);
  }
  if (matrix) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(matrix));
    if (message_arena != submessage_arena) {
      matrix = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, matrix, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.matrix_ = matrix;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneMatrix.matrix)
}

// .frame.proto.UniformQuaternion quaternion = 4;
inline bool SceneMatrix::_internal_has_quaternion() const {
  return this != internal_default_instance() && _impl_.quaternion_ != nullptr;
}
inline bool SceneMatrix::has_quaternion() const {
  return _internal_has_quaternion();
}
inline const ::frame::proto::UniformQuaternion& SceneMatrix::_internal_quaternion() const {
  const ::frame::proto::UniformQuaternion* p = _impl_.quaternion_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformQuaternion&>(
      ::frame::proto::_UniformQuaternion_default_instance_);
}
inline const ::frame::proto::UniformQuaternion& SceneMatrix::quaternion() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneMatrix.quaternion)
  return _internal_quaternion();
}
inline void SceneMatrix::unsafe_arena_set_allocated_quaternion(
    ::frame::proto::UniformQuaternion* quaternion) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quaternion_);
  }
  _impl_.quaternion_ = quaternion;
  if (quaternion) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneMatrix.quaternion)
}
inline ::frame::proto::UniformQuaternion* SceneMatrix::release_quaternion() {
  
  ::frame::proto::UniformQuaternion* temp = _impl_.quaternion_;
  _impl_.quaternion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::frame::proto::UniformQuaternion* SceneMatrix::unsafe_arena_release_quaternion() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneMatrix.quaternion)
  
  ::frame::proto::UniformQuaternion* temp = _impl_.quaternion_;
  _impl_.quaternion_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformQuaternion* SceneMatrix::_internal_mutable_quaternion() {
  
  if (_impl_.quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformQuaternion>(GetArenaForAllocation());
    _impl_.quaternion_ = p;
  }
  return _impl_.quaternion_;
}
inline ::frame::proto::UniformQuaternion* SceneMatrix::mutable_quaternion() {
  ::frame::proto::UniformQuaternion* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneMatrix.quaternion)
  return _msg;
}
inline void SceneMatrix::set_allocated_quaternion(::frame::proto::UniformQuaternion* quaternion) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.quaternion_);
  }
  if (quaternion) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(quaternion));
    if (message_arena != submessage_arena) {
      quaternion = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, quaternion, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.quaternion_ = quaternion;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneMatrix.quaternion)
}

// -------------------------------------------------------------------

// SceneStaticMesh

// string name = 1;
inline void SceneStaticMesh::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SceneStaticMesh::name() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneStaticMesh::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.name)
}
inline std::string* SceneStaticMesh::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.name)
  return _s;
}
inline const std::string& SceneStaticMesh::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SceneStaticMesh::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneStaticMesh::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneStaticMesh::release_name() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.name)
  return _impl_.name_.Release();
}
inline void SceneStaticMesh::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneStaticMesh.name)
}

// string parent = 2;
inline void SceneStaticMesh::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& SceneStaticMesh::parent() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneStaticMesh::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.parent)
}
inline std::string* SceneStaticMesh::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.parent)
  return _s;
}
inline const std::string& SceneStaticMesh::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void SceneStaticMesh::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneStaticMesh::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneStaticMesh::release_parent() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.parent)
  return _impl_.parent_.Release();
}
inline void SceneStaticMesh::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneStaticMesh.parent)
}

// .frame.proto.SceneStaticMesh.RenderPrimitiveEnum render_primitive_enum = 8;
inline void SceneStaticMesh::clear_render_primitive_enum() {
  _impl_.render_primitive_enum_ = 0;
}
inline ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum SceneStaticMesh::_internal_render_primitive_enum() const {
  return static_cast< ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum >(_impl_.render_primitive_enum_);
}
inline ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum SceneStaticMesh::render_primitive_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.render_primitive_enum)
  return _internal_render_primitive_enum();
}
inline void SceneStaticMesh::_internal_set_render_primitive_enum(::frame::proto::SceneStaticMesh_RenderPrimitiveEnum value) {
  
  _impl_.render_primitive_enum_ = value;
}
inline void SceneStaticMesh::set_render_primitive_enum(::frame::proto::SceneStaticMesh_RenderPrimitiveEnum value) {
  _internal_set_render_primitive_enum(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.render_primitive_enum)
}

// .frame.proto.CleanBuffer clean_buffer = 7;
inline bool SceneStaticMesh::_internal_has_clean_buffer() const {
  return mesh_oneof_case() == kCleanBuffer;
}
inline bool SceneStaticMesh::has_clean_buffer() const {
  return _internal_has_clean_buffer();
}
inline void SceneStaticMesh::set_has_clean_buffer() {
  _impl_._oneof_case_[0] = kCleanBuffer;
}
inline ::frame::proto::CleanBuffer* SceneStaticMesh::release_clean_buffer() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.clean_buffer)
  if (_internal_has_clean_buffer()) {
    clear_has_mesh_oneof();
    ::frame::proto::CleanBuffer* temp = _impl_.mesh_oneof_.clean_buffer_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mesh_oneof_.clean_buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::frame::proto::CleanBuffer& SceneStaticMesh::_internal_clean_buffer() const {
  return _internal_has_clean_buffer()
      ? *_impl_.mesh_oneof_.clean_buffer_
      : reinterpret_cast< ::frame::proto::CleanBuffer&>(::frame::proto::_CleanBuffer_default_instance_);
}
inline const ::frame::proto::CleanBuffer& SceneStaticMesh::clean_buffer() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.clean_buffer)
  return _internal_clean_buffer();
}
inline ::frame::proto::CleanBuffer* SceneStaticMesh::unsafe_arena_release_clean_buffer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:frame.proto.SceneStaticMesh.clean_buffer)
  if (_internal_has_clean_buffer()) {
    clear_has_mesh_oneof();
    ::frame::proto::CleanBuffer* temp = _impl_.mesh_oneof_.clean_buffer_;
    _impl_.mesh_oneof_.clean_buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SceneStaticMesh::unsafe_arena_set_allocated_clean_buffer(::frame::proto::CleanBuffer* clean_buffer) {
  clear_mesh_oneof();
  if (clean_buffer) {
    set_has_clean_buffer();
    _impl_.mesh_oneof_.clean_buffer_ = clean_buffer;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneStaticMesh.clean_buffer)
}
inline ::frame::proto::CleanBuffer* SceneStaticMesh::_internal_mutable_clean_buffer() {
  if (!_internal_has_clean_buffer()) {
    clear_mesh_oneof();
    set_has_clean_buffer();
    _impl_.mesh_oneof_.clean_buffer_ = CreateMaybeMessage< ::frame::proto::CleanBuffer >(GetArenaForAllocation());
  }
  return _impl_.mesh_oneof_.clean_buffer_;
}
inline ::frame::proto::CleanBuffer* SceneStaticMesh::mutable_clean_buffer() {
  ::frame::proto::CleanBuffer* _msg = _internal_mutable_clean_buffer();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.clean_buffer)
  return _msg;
}

// .frame.proto.SceneStaticMesh.MeshEnum mesh_enum = 6;
inline bool SceneStaticMesh::_internal_has_mesh_enum() const {
  return mesh_oneof_case() == kMeshEnum;
}
inline bool SceneStaticMesh::has_mesh_enum() const {
  return _internal_has_mesh_enum();
}
inline void SceneStaticMesh::set_has_mesh_enum() {
  _impl_._oneof_case_[0] = kMeshEnum;
}
inline void SceneStaticMesh::clear_mesh_enum() {
  if (_internal_has_mesh_enum()) {
    _impl_.mesh_oneof_.mesh_enum_ = 0;
    clear_has_mesh_oneof();
  }
}
inline ::frame::proto::SceneStaticMesh_MeshEnum SceneStaticMesh::_internal_mesh_enum() const {
  if (_internal_has_mesh_enum()) {
    return static_cast< ::frame::proto::SceneStaticMesh_MeshEnum >(_impl_.mesh_oneof_.mesh_enum_);
  }
  return static_cast< ::frame::proto::SceneStaticMesh_MeshEnum >(0);
}
inline ::frame::proto::SceneStaticMesh_MeshEnum SceneStaticMesh::mesh_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.mesh_enum)
  return _internal_mesh_enum();
}
inline void SceneStaticMesh::_internal_set_mesh_enum(::frame::proto::SceneStaticMesh_MeshEnum value) {
  if (!_internal_has_mesh_enum()) {
    clear_mesh_oneof();
    set_has_mesh_enum();
  }
  _impl_.mesh_oneof_.mesh_enum_ = value;
}
inline void SceneStaticMesh::set_mesh_enum(::frame::proto::SceneStaticMesh_MeshEnum value) {
  _internal_set_mesh_enum(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.mesh_enum)
}

// string file_name = 3;
inline bool SceneStaticMesh::_internal_has_file_name() const {
  return mesh_oneof_case() == kFileName;
}
inline bool SceneStaticMesh::has_file_name() const {
  return _internal_has_file_name();
}
inline void SceneStaticMesh::set_has_file_name() {
  _impl_._oneof_case_[0] = kFileName;
}
inline void SceneStaticMesh::clear_file_name() {
  if (_internal_has_file_name()) {
    _impl_.mesh_oneof_.file_name_.Destroy();
    clear_has_mesh_oneof();
  }
}
inline const std::string& SceneStaticMesh::file_name() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.file_name)
  return _internal_file_name();
}
template <typename ArgT0, typename... ArgT>
inline void SceneStaticMesh::set_file_name(ArgT0&& arg0, ArgT... args) {
  if (!_internal_has_file_name()) {
    clear_mesh_oneof();
    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitDefault();
  }
  _impl_.mesh_oneof_.file_name_.Set( static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.file_name)
}
inline std::string* SceneStaticMesh::mutable_file_name() {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.file_name)
  return _s;
}
inline const std::string& SceneStaticMesh::_internal_file_name() const {
  if (_internal_has_file_name()) {
    return _impl_.mesh_oneof_.file_name_.Get();
  }
  return ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void SceneStaticMesh::_internal_set_file_name(const std::string& value) {
  if (!_internal_has_file_name()) {
    clear_mesh_oneof();
    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitDefault();
  }
  _impl_.mesh_oneof_.file_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneStaticMesh::_internal_mutable_file_name() {
  if (!_internal_has_file_name()) {
    clear_mesh_oneof();
    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitDefault();
  }
  return _impl_.mesh_oneof_.file_name_.Mutable(      GetArenaForAllocation());
}
inline std::string* SceneStaticMesh::release_file_name() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.file_name)
  if (_internal_has_file_name()) {
    clear_has_mesh_oneof();
    return _impl_.mesh_oneof_.file_name_.Release();
  } else {
    return nullptr;
  }
}
inline void SceneStaticMesh::set_allocated_file_name(std::string* file_name) {
  if (has_mesh_oneof()) {
    clear_mesh_oneof();
  }
  if (file_name != nullptr) {
    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitAllocated(file_name, GetArenaForAllocation());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneStaticMesh.file_name)
}

// .frame.proto.Stream stream = 10;
inline bool SceneStaticMesh::_internal_has_stream() const {
  return mesh_oneof_case() == kStream;
}
inline bool SceneStaticMesh::has_stream() const {
  return _internal_has_stream();
}
inline void SceneStaticMesh::set_has_stream() {
  _impl_._oneof_case_[0] = kStream;
}
inline ::frame::proto::Stream* SceneStaticMesh::release_stream() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.stream)
  if (_internal_has_stream()) {
    clear_has_mesh_oneof();
    ::frame::proto::Stream* temp = _impl_.mesh_oneof_.stream_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mesh_oneof_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::frame::proto::Stream& SceneStaticMesh::_internal_stream() const {
  return _internal_has_stream()
      ? *_impl_.mesh_oneof_.stream_
      : reinterpret_cast< ::frame::proto::Stream&>(::frame::proto::_Stream_default_instance_);
}
inline const ::frame::proto::Stream& SceneStaticMesh::stream() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.stream)
  return _internal_stream();
}
inline ::frame::proto::Stream* SceneStaticMesh::unsafe_arena_release_stream() {
  // @@protoc_insertion_point(field_unsafe_arena_release:frame.proto.SceneStaticMesh.stream)
  if (_internal_has_stream()) {
    clear_has_mesh_oneof();
    ::frame::proto::Stream* temp = _impl_.mesh_oneof_.stream_;
    _impl_.mesh_oneof_.stream_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SceneStaticMesh::unsafe_arena_set_allocated_stream(::frame::proto::Stream* stream) {
  clear_mesh_oneof();
  if (stream) {
    set_has_stream();
    _impl_.mesh_oneof_.stream_ = stream;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneStaticMesh.stream)
}
inline ::frame::proto::Stream* SceneStaticMesh::_internal_mutable_stream() {
  if (!_internal_has_stream()) {
    clear_mesh_oneof();
    set_has_stream();
    _impl_.mesh_oneof_.stream_ = CreateMaybeMessage< ::frame::proto::Stream >(GetArenaForAllocation());
  }
  return _impl_.mesh_oneof_.stream_;
}
inline ::frame::proto::Stream* SceneStaticMesh::mutable_stream() {
  ::frame::proto::Stream* _msg = _internal_mutable_stream();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.stream)
  return _msg;
}

// string material_name = 5;
inline void SceneStaticMesh::clear_material_name() {
  _impl_.material_name_.ClearToEmpty();
}
inline const std::string& SceneStaticMesh::material_name() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.material_name)
  return _internal_material_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneStaticMesh::set_material_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.material_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.material_name)
}
inline std::string* SceneStaticMesh::mutable_material_name() {
  std::string* _s = _internal_mutable_material_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.material_name)
  return _s;
}
inline const std::string& SceneStaticMesh::_internal_material_name() const {
  return _impl_.material_name_.Get();
}
inline void SceneStaticMesh::_internal_set_material_name(const std::string& value) {
  
  _impl_.material_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneStaticMesh::_internal_mutable_material_name() {
  
  return _impl_.material_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneStaticMesh::release_material_name() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.material_name)
  return _impl_.material_name_.Release();
}
inline void SceneStaticMesh::set_allocated_material_name(std::string* material_name) {
  if (material_name != nullptr) {
    
  } else {
    
  }
  _impl_.material_name_.SetAllocated(material_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.material_name_.IsDefault()) {
    _impl_.material_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneStaticMesh.material_name)
}

inline bool SceneStaticMesh::has_mesh_oneof() const {
  return mesh_oneof_case() != MESH_ONEOF_NOT_SET;
}
inline void SceneStaticMesh::clear_has_mesh_oneof() {
  _impl_._oneof_case_[0] = MESH_ONEOF_NOT_SET;
}
inline SceneStaticMesh::MeshOneofCase SceneStaticMesh::mesh_oneof_case() const {
  return SceneStaticMesh::MeshOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SceneCamera

// string name = 1;
inline void SceneCamera::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SceneCamera::name() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneCamera::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.name)
}
inline std::string* SceneCamera::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneCamera.name)
  return _s;
}
inline const std::string& SceneCamera::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SceneCamera::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneCamera::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneCamera::release_name() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneCamera.name)
  return _impl_.name_.Release();
}
inline void SceneCamera::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneCamera.name)
}

// string parent = 2;
inline void SceneCamera::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& SceneCamera::parent() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneCamera::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.parent)
}
inline std::string* SceneCamera::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneCamera.parent)
  return _s;
}
inline const std::string& SceneCamera::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void SceneCamera::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneCamera::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneCamera::release_parent() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneCamera.parent)
  return _impl_.parent_.Release();
}
inline void SceneCamera::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneCamera.parent)
}

// .frame.proto.UniformVector3 position = 3;
inline bool SceneCamera::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool SceneCamera::has_position() const {
  return _internal_has_position();
}
inline const ::frame::proto::UniformVector3& SceneCamera::_internal_position() const {
  const ::frame::proto::UniformVector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(
      ::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneCamera::position() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.position)
  return _internal_position();
}
inline void SceneCamera::unsafe_arena_set_allocated_position(
    ::frame::proto::UniformVector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneCamera.position)
}
inline ::frame::proto::UniformVector3* SceneCamera::release_position() {
  
  ::frame::proto::UniformVector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::frame::proto::UniformVector3* SceneCamera::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneCamera.position)
  
  ::frame::proto::UniformVector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneCamera::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::frame::proto::UniformVector3* SceneCamera::mutable_position() {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneCamera.position)
  return _msg;
}
inline void SceneCamera::set_allocated_position(::frame::proto::UniformVector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneCamera.position)
}

// .frame.proto.UniformVector3 target = 4;
inline bool SceneCamera::_internal_has_target() const {
  return this != internal_default_instance() && _impl_.target_ != nullptr;
}
inline bool SceneCamera::has_target() const {
  return _internal_has_target();
}
inline const ::frame::proto::UniformVector3& SceneCamera::_internal_target() const {
  const ::frame::proto::UniformVector3* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(
      ::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneCamera::target() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.target)
  return _internal_target();
}
inline void SceneCamera::unsafe_arena_set_allocated_target(
    ::frame::proto::UniformVector3* target) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = target;
  if (target) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneCamera.target)
}
inline ::frame::proto::UniformVector3* SceneCamera::release_target() {
  
  ::frame::proto::UniformVector3* temp = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::frame::proto::UniformVector3* SceneCamera::unsafe_arena_release_target() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneCamera.target)
  
  ::frame::proto::UniformVector3* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneCamera::_internal_mutable_target() {
  
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArenaForAllocation());
    _impl_.target_ = p;
  }
  return _impl_.target_;
}
inline ::frame::proto::UniformVector3* SceneCamera::mutable_target() {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneCamera.target)
  return _msg;
}
inline void SceneCamera::set_allocated_target(::frame::proto::UniformVector3* target) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.target_);
  }
  if (target) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(target));
    if (message_arena != submessage_arena) {
      target = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, target, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.target_ = target;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneCamera.target)
}

// .frame.proto.UniformVector3 up = 5;
inline bool SceneCamera::_internal_has_up() const {
  return this != internal_default_instance() && _impl_.up_ != nullptr;
}
inline bool SceneCamera::has_up() const {
  return _internal_has_up();
}
inline const ::frame::proto::UniformVector3& SceneCamera::_internal_up() const {
  const ::frame::proto::UniformVector3* p = _impl_.up_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(
      ::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneCamera::up() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.up)
  return _internal_up();
}
inline void SceneCamera::unsafe_arena_set_allocated_up(
    ::frame::proto::UniformVector3* up) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.up_);
  }
  _impl_.up_ = up;
  if (up) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneCamera.up)
}
inline ::frame::proto::UniformVector3* SceneCamera::release_up() {
  
  ::frame::proto::UniformVector3* temp = _impl_.up_;
  _impl_.up_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::frame::proto::UniformVector3* SceneCamera::unsafe_arena_release_up() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneCamera.up)
  
  ::frame::proto::UniformVector3* temp = _impl_.up_;
  _impl_.up_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneCamera::_internal_mutable_up() {
  
  if (_impl_.up_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArenaForAllocation());
    _impl_.up_ = p;
  }
  return _impl_.up_;
}
inline ::frame::proto::UniformVector3* SceneCamera::mutable_up() {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_up();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneCamera.up)
  return _msg;
}
inline void SceneCamera::set_allocated_up(::frame::proto::UniformVector3* up) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.up_);
  }
  if (up) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(up));
    if (message_arena != submessage_arena) {
      up = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, up, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.up_ = up;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneCamera.up)
}

// float fov_degrees = 6;
inline void SceneCamera::clear_fov_degrees() {
  _impl_.fov_degrees_ = 0;
}
inline float SceneCamera::_internal_fov_degrees() const {
  return _impl_.fov_degrees_;
}
inline float SceneCamera::fov_degrees() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.fov_degrees)
  return _internal_fov_degrees();
}
inline void SceneCamera::_internal_set_fov_degrees(float value) {
  
  _impl_.fov_degrees_ = value;
}
inline void SceneCamera::set_fov_degrees(float value) {
  _internal_set_fov_degrees(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.fov_degrees)
}

// float aspect_ratio = 7;
inline void SceneCamera::clear_aspect_ratio() {
  _impl_.aspect_ratio_ = 0;
}
inline float SceneCamera::_internal_aspect_ratio() const {
  return _impl_.aspect_ratio_;
}
inline float SceneCamera::aspect_ratio() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.aspect_ratio)
  return _internal_aspect_ratio();
}
inline void SceneCamera::_internal_set_aspect_ratio(float value) {
  
  _impl_.aspect_ratio_ = value;
}
inline void SceneCamera::set_aspect_ratio(float value) {
  _internal_set_aspect_ratio(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.aspect_ratio)
}

// float near_clip = 8;
inline void SceneCamera::clear_near_clip() {
  _impl_.near_clip_ = 0;
}
inline float SceneCamera::_internal_near_clip() const {
  return _impl_.near_clip_;
}
inline float SceneCamera::near_clip() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.near_clip)
  return _internal_near_clip();
}
inline void SceneCamera::_internal_set_near_clip(float value) {
  
  _impl_.near_clip_ = value;
}
inline void SceneCamera::set_near_clip(float value) {
  _internal_set_near_clip(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.near_clip)
}

// float far_clip = 9;
inline void SceneCamera::clear_far_clip() {
  _impl_.far_clip_ = 0;
}
inline float SceneCamera::_internal_far_clip() const {
  return _impl_.far_clip_;
}
inline float SceneCamera::far_clip() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.far_clip)
  return _internal_far_clip();
}
inline void SceneCamera::_internal_set_far_clip(float value) {
  
  _impl_.far_clip_ = value;
}
inline void SceneCamera::set_far_clip(float value) {
  _internal_set_far_clip(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.far_clip)
}

// -------------------------------------------------------------------

// SceneLight

// string name = 1;
inline void SceneLight::clear_name() {
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SceneLight::name() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneLight::set_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.name)
}
inline std::string* SceneLight::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.name)
  return _s;
}
inline const std::string& SceneLight::_internal_name() const {
  return _impl_.name_.Get();
}
inline void SceneLight::_internal_set_name(const std::string& value) {
  
  _impl_.name_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneLight::_internal_mutable_name() {
  
  return _impl_.name_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneLight::release_name() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.name)
  return _impl_.name_.Release();
}
inline void SceneLight::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  _impl_.name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.name_.IsDefault()) {
    _impl_.name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.name)
}

// string parent = 2;
inline void SceneLight::clear_parent() {
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& SceneLight::parent() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.parent)
  return _internal_parent();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneLight::set_parent(ArgT0&& arg0, ArgT... args) {
 
 _impl_.parent_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.parent)
}
inline std::string* SceneLight::mutable_parent() {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.parent)
  return _s;
}
inline const std::string& SceneLight::_internal_parent() const {
  return _impl_.parent_.Get();
}
inline void SceneLight::_internal_set_parent(const std::string& value) {
  
  _impl_.parent_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneLight::_internal_mutable_parent() {
  
  return _impl_.parent_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneLight::release_parent() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.parent)
  return _impl_.parent_.Release();
}
inline void SceneLight::set_allocated_parent(std::string* parent) {
  if (parent != nullptr) {
    
  } else {
    
  }
  _impl_.parent_.SetAllocated(parent, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.parent_.IsDefault()) {
    _impl_.parent_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.parent)
}

// .frame.proto.SceneLight.Enum light_type = 3;
inline void SceneLight::clear_light_type() {
  _impl_.light_type_ = 0;
}
inline ::frame::proto::SceneLight_Enum SceneLight::_internal_light_type() const {
  return static_cast< ::frame::proto::SceneLight_Enum >(_impl_.light_type_);
}
inline ::frame::proto::SceneLight_Enum SceneLight::light_type() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.light_type)
  return _internal_light_type();
}
inline void SceneLight::_internal_set_light_type(::frame::proto::SceneLight_Enum value) {
  
  _impl_.light_type_ = value;
}
inline void SceneLight::set_light_type(::frame::proto::SceneLight_Enum value) {
  _internal_set_light_type(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.light_type)
}

// .frame.proto.UniformVector3 position = 4;
inline bool SceneLight::_internal_has_position() const {
  return this != internal_default_instance() && _impl_.position_ != nullptr;
}
inline bool SceneLight::has_position() const {
  return _internal_has_position();
}
inline const ::frame::proto::UniformVector3& SceneLight::_internal_position() const {
  const ::frame::proto::UniformVector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(
      ::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneLight::position() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.position)
  return _internal_position();
}
inline void SceneLight::unsafe_arena_set_allocated_position(
    ::frame::proto::UniformVector3* position) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = position;
  if (position) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneLight.position)
}
inline ::frame::proto::UniformVector3* SceneLight::release_position() {
  
  ::frame::proto::UniformVector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::frame::proto::UniformVector3* SceneLight::unsafe_arena_release_position() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.position)
  
  ::frame::proto::UniformVector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneLight::_internal_mutable_position() {
  
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArenaForAllocation());
    _impl_.position_ = p;
  }
  return _impl_.position_;
}
inline ::frame::proto::UniformVector3* SceneLight::mutable_position() {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.position)
  return _msg;
}
inline void SceneLight::set_allocated_position(::frame::proto::UniformVector3* position) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.position_);
  }
  if (position) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(position));
    if (message_arena != submessage_arena) {
      position = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, position, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.position_ = position;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.position)
}

// .frame.proto.UniformVector3 direction = 5;
inline bool SceneLight::_internal_has_direction() const {
  return this != internal_default_instance() && _impl_.direction_ != nullptr;
}
inline bool SceneLight::has_direction() const {
  return _internal_has_direction();
}
inline const ::frame::proto::UniformVector3& SceneLight::_internal_direction() const {
  const ::frame::proto::UniformVector3* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(
      ::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneLight::direction() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.direction)
  return _internal_direction();
}
inline void SceneLight::unsafe_arena_set_allocated_direction(
    ::frame::proto::UniformVector3* direction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = direction;
  if (direction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneLight.direction)
}
inline ::frame::proto::UniformVector3* SceneLight::release_direction() {
  
  ::frame::proto::UniformVector3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::frame::proto::UniformVector3* SceneLight::unsafe_arena_release_direction() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.direction)
  
  ::frame::proto::UniformVector3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneLight::_internal_mutable_direction() {
  
  if (_impl_.direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArenaForAllocation());
    _impl_.direction_ = p;
  }
  return _impl_.direction_;
}
inline ::frame::proto::UniformVector3* SceneLight::mutable_direction() {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.direction)
  return _msg;
}
inline void SceneLight::set_allocated_direction(::frame::proto::UniformVector3* direction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.direction_);
  }
  if (direction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direction));
    if (message_arena != submessage_arena) {
      direction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direction, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.direction_ = direction;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.direction)
}

// float dot_inner_limit = 6;
inline void SceneLight::clear_dot_inner_limit() {
  _impl_.dot_inner_limit_ = 0;
}
inline float SceneLight::_internal_dot_inner_limit() const {
  return _impl_.dot_inner_limit_;
}
inline float SceneLight::dot_inner_limit() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.dot_inner_limit)
  return _internal_dot_inner_limit();
}
inline void SceneLight::_internal_set_dot_inner_limit(float value) {
  
  _impl_.dot_inner_limit_ = value;
}
inline void SceneLight::set_dot_inner_limit(float value) {
  _internal_set_dot_inner_limit(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.dot_inner_limit)
}

// float dot_outer_limit = 7;
inline void SceneLight::clear_dot_outer_limit() {
  _impl_.dot_outer_limit_ = 0;
}
inline float SceneLight::_internal_dot_outer_limit() const {
  return _impl_.dot_outer_limit_;
}
inline float SceneLight::dot_outer_limit() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.dot_outer_limit)
  return _internal_dot_outer_limit();
}
inline void SceneLight::_internal_set_dot_outer_limit(float value) {
  
  _impl_.dot_outer_limit_ = value;
}
inline void SceneLight::set_dot_outer_limit(float value) {
  _internal_set_dot_outer_limit(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.dot_outer_limit)
}

// .frame.proto.UniformVector3 color = 8;
inline bool SceneLight::_internal_has_color() const {
  return this != internal_default_instance() && _impl_.color_ != nullptr;
}
inline bool SceneLight::has_color() const {
  return _internal_has_color();
}
inline const ::frame::proto::UniformVector3& SceneLight::_internal_color() const {
  const ::frame::proto::UniformVector3* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(
      ::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneLight::color() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.color)
  return _internal_color();
}
inline void SceneLight::unsafe_arena_set_allocated_color(
    ::frame::proto::UniformVector3* color) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = color;
  if (color) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneLight.color)
}
inline ::frame::proto::UniformVector3* SceneLight::release_color() {
  
  ::frame::proto::UniformVector3* temp = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::frame::proto::UniformVector3* SceneLight::unsafe_arena_release_color() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.color)
  
  ::frame::proto::UniformVector3* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneLight::_internal_mutable_color() {
  
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArenaForAllocation());
    _impl_.color_ = p;
  }
  return _impl_.color_;
}
inline ::frame::proto::UniformVector3* SceneLight::mutable_color() {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.color)
  return _msg;
}
inline void SceneLight::set_allocated_color(::frame::proto::UniformVector3* color) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(_impl_.color_);
  }
  if (color) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(
                reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(color));
    if (message_arena != submessage_arena) {
      color = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, color, submessage_arena);
    }
    
  } else {
    
  }
  _impl_.color_ = color;
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.color)
}

// -------------------------------------------------------------------

// SceneTree

// string default_root_name = 1;
inline void SceneTree::clear_default_root_name() {
  _impl_.default_root_name_.ClearToEmpty();
}
inline const std::string& SceneTree::default_root_name() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.default_root_name)
  return _internal_default_root_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneTree::set_default_root_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_root_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneTree.default_root_name)
}
inline std::string* SceneTree::mutable_default_root_name() {
  std::string* _s = _internal_mutable_default_root_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.default_root_name)
  return _s;
}
inline const std::string& SceneTree::_internal_default_root_name() const {
  return _impl_.default_root_name_.Get();
}
inline void SceneTree::_internal_set_default_root_name(const std::string& value) {
  
  _impl_.default_root_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneTree::_internal_mutable_default_root_name() {
  
  return _impl_.default_root_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneTree::release_default_root_name() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneTree.default_root_name)
  return _impl_.default_root_name_.Release();
}
inline void SceneTree::set_allocated_default_root_name(std::string* default_root_name) {
  if (default_root_name != nullptr) {
    
  } else {
    
  }
  _impl_.default_root_name_.SetAllocated(default_root_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_root_name_.IsDefault()) {
    _impl_.default_root_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneTree.default_root_name)
}

// string default_camera_name = 2;
inline void SceneTree::clear_default_camera_name() {
  _impl_.default_camera_name_.ClearToEmpty();
}
inline const std::string& SceneTree::default_camera_name() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.default_camera_name)
  return _internal_default_camera_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SceneTree::set_default_camera_name(ArgT0&& arg0, ArgT... args) {
 
 _impl_.default_camera_name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:frame.proto.SceneTree.default_camera_name)
}
inline std::string* SceneTree::mutable_default_camera_name() {
  std::string* _s = _internal_mutable_default_camera_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.default_camera_name)
  return _s;
}
inline const std::string& SceneTree::_internal_default_camera_name() const {
  return _impl_.default_camera_name_.Get();
}
inline void SceneTree::_internal_set_default_camera_name(const std::string& value) {
  
  _impl_.default_camera_name_.Set(value, GetArenaForAllocation());
}
inline std::string* SceneTree::_internal_mutable_default_camera_name() {
  
  return _impl_.default_camera_name_.Mutable(GetArenaForAllocation());
}
inline std::string* SceneTree::release_default_camera_name() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneTree.default_camera_name)
  return _impl_.default_camera_name_.Release();
}
inline void SceneTree::set_allocated_default_camera_name(std::string* default_camera_name) {
  if (default_camera_name != nullptr) {
    
  } else {
    
  }
  _impl_.default_camera_name_.SetAllocated(default_camera_name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.default_camera_name_.IsDefault()) {
    _impl_.default_camera_name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneTree.default_camera_name)
}

// repeated .frame.proto.SceneMatrix scene_matrices = 3;
inline int SceneTree::_internal_scene_matrices_size() const {
  return _impl_.scene_matrices_.size();
}
inline int SceneTree::scene_matrices_size() const {
  return _internal_scene_matrices_size();
}
inline void SceneTree::clear_scene_matrices() {
  _impl_.scene_matrices_.Clear();
}
inline ::frame::proto::SceneMatrix* SceneTree::mutable_scene_matrices(int index) {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.scene_matrices)
  return _impl_.scene_matrices_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneMatrix >*
SceneTree::mutable_scene_matrices() {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.scene_matrices)
  return &_impl_.scene_matrices_;
}
inline const ::frame::proto::SceneMatrix& SceneTree::_internal_scene_matrices(int index) const {
  return _impl_.scene_matrices_.Get(index);
}
inline const ::frame::proto::SceneMatrix& SceneTree::scene_matrices(int index) const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.scene_matrices)
  return _internal_scene_matrices(index);
}
inline ::frame::proto::SceneMatrix* SceneTree::_internal_add_scene_matrices() {
  return _impl_.scene_matrices_.Add();
}
inline ::frame::proto::SceneMatrix* SceneTree::add_scene_matrices() {
  ::frame::proto::SceneMatrix* _add = _internal_add_scene_matrices();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.scene_matrices)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneMatrix >&
SceneTree::scene_matrices() const {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.scene_matrices)
  return _impl_.scene_matrices_;
}

// repeated .frame.proto.SceneStaticMesh scene_static_meshes = 4;
inline int SceneTree::_internal_scene_static_meshes_size() const {
  return _impl_.scene_static_meshes_.size();
}
inline int SceneTree::scene_static_meshes_size() const {
  return _internal_scene_static_meshes_size();
}
inline void SceneTree::clear_scene_static_meshes() {
  _impl_.scene_static_meshes_.Clear();
}
inline ::frame::proto::SceneStaticMesh* SceneTree::mutable_scene_static_meshes(int index) {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.scene_static_meshes)
  return _impl_.scene_static_meshes_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneStaticMesh >*
SceneTree::mutable_scene_static_meshes() {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.scene_static_meshes)
  return &_impl_.scene_static_meshes_;
}
inline const ::frame::proto::SceneStaticMesh& SceneTree::_internal_scene_static_meshes(int index) const {
  return _impl_.scene_static_meshes_.Get(index);
}
inline const ::frame::proto::SceneStaticMesh& SceneTree::scene_static_meshes(int index) const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.scene_static_meshes)
  return _internal_scene_static_meshes(index);
}
inline ::frame::proto::SceneStaticMesh* SceneTree::_internal_add_scene_static_meshes() {
  return _impl_.scene_static_meshes_.Add();
}
inline ::frame::proto::SceneStaticMesh* SceneTree::add_scene_static_meshes() {
  ::frame::proto::SceneStaticMesh* _add = _internal_add_scene_static_meshes();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.scene_static_meshes)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneStaticMesh >&
SceneTree::scene_static_meshes() const {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.scene_static_meshes)
  return _impl_.scene_static_meshes_;
}

// repeated .frame.proto.SceneCamera scene_cameras = 5;
inline int SceneTree::_internal_scene_cameras_size() const {
  return _impl_.scene_cameras_.size();
}
inline int SceneTree::scene_cameras_size() const {
  return _internal_scene_cameras_size();
}
inline void SceneTree::clear_scene_cameras() {
  _impl_.scene_cameras_.Clear();
}
inline ::frame::proto::SceneCamera* SceneTree::mutable_scene_cameras(int index) {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.scene_cameras)
  return _impl_.scene_cameras_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneCamera >*
SceneTree::mutable_scene_cameras() {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.scene_cameras)
  return &_impl_.scene_cameras_;
}
inline const ::frame::proto::SceneCamera& SceneTree::_internal_scene_cameras(int index) const {
  return _impl_.scene_cameras_.Get(index);
}
inline const ::frame::proto::SceneCamera& SceneTree::scene_cameras(int index) const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.scene_cameras)
  return _internal_scene_cameras(index);
}
inline ::frame::proto::SceneCamera* SceneTree::_internal_add_scene_cameras() {
  return _impl_.scene_cameras_.Add();
}
inline ::frame::proto::SceneCamera* SceneTree::add_scene_cameras() {
  ::frame::proto::SceneCamera* _add = _internal_add_scene_cameras();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.scene_cameras)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneCamera >&
SceneTree::scene_cameras() const {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.scene_cameras)
  return _impl_.scene_cameras_;
}

// repeated .frame.proto.SceneLight scene_lights = 6;
inline int SceneTree::_internal_scene_lights_size() const {
  return _impl_.scene_lights_.size();
}
inline int SceneTree::scene_lights_size() const {
  return _internal_scene_lights_size();
}
inline void SceneTree::clear_scene_lights() {
  _impl_.scene_lights_.Clear();
}
inline ::frame::proto::SceneLight* SceneTree::mutable_scene_lights(int index) {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.scene_lights)
  return _impl_.scene_lights_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneLight >*
SceneTree::mutable_scene_lights() {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.scene_lights)
  return &_impl_.scene_lights_;
}
inline const ::frame::proto::SceneLight& SceneTree::_internal_scene_lights(int index) const {
  return _impl_.scene_lights_.Get(index);
}
inline const ::frame::proto::SceneLight& SceneTree::scene_lights(int index) const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.scene_lights)
  return _internal_scene_lights(index);
}
inline ::frame::proto::SceneLight* SceneTree::_internal_add_scene_lights() {
  return _impl_.scene_lights_.Add();
}
inline ::frame::proto::SceneLight* SceneTree::add_scene_lights() {
  ::frame::proto::SceneLight* _add = _internal_add_scene_lights();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.scene_lights)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::frame::proto::SceneLight >&
SceneTree::scene_lights() const {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.scene_lights)
  return _impl_.scene_lights_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace proto
}  // namespace frame

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum>() {
  return ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum_descriptor();
}
template <> struct is_proto_enum< ::frame::proto::SceneStaticMesh_MeshEnum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::frame::proto::SceneStaticMesh_MeshEnum>() {
  return ::frame::proto::SceneStaticMesh_MeshEnum_descriptor();
}
template <> struct is_proto_enum< ::frame::proto::SceneLight_Enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::frame::proto::SceneLight_Enum>() {
  return ::frame::proto::SceneLight_Enum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_scene_2eproto
