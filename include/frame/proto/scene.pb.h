// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: scene.proto
// Protobuf C++ Version: 4.25.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_scene_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_scene_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/port_def.inc"
#if PROTOBUF_VERSION < 4025000
#error "This file was generated by a newer version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please update"
#error "your headers."
#endif  // PROTOBUF_VERSION

#if 4025001 < PROTOBUF_MIN_PROTOC_VERSION
#error "This file was generated by an older version of protoc which is"
#error "incompatible with your Protocol Buffer headers. Please"
#error "regenerate this file with a newer version of protoc."
#endif  // PROTOBUF_MIN_PROTOC_VERSION
#include "google/protobuf/port_undef.inc"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/message.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/unknown_field_set.h"
#include "pixel.pb.h"
#include "math.pb.h"
#include "plugin.pb.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_scene_2eproto

namespace google {
namespace protobuf {
namespace internal {
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_scene_2eproto {
  static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_scene_2eproto;
namespace frame {
namespace proto {
class SceneCamera;
struct SceneCameraDefaultTypeInternal;
extern SceneCameraDefaultTypeInternal _SceneCamera_default_instance_;
class SceneLight;
struct SceneLightDefaultTypeInternal;
extern SceneLightDefaultTypeInternal _SceneLight_default_instance_;
class SceneMatrix;
struct SceneMatrixDefaultTypeInternal;
extern SceneMatrixDefaultTypeInternal _SceneMatrix_default_instance_;
class SceneStaticMesh;
struct SceneStaticMeshDefaultTypeInternal;
extern SceneStaticMeshDefaultTypeInternal _SceneStaticMesh_default_instance_;
class SceneTree;
struct SceneTreeDefaultTypeInternal;
extern SceneTreeDefaultTypeInternal _SceneTree_default_instance_;
}  // namespace proto
}  // namespace frame
namespace google {
namespace protobuf {
}  // namespace protobuf
}  // namespace google

namespace frame {
namespace proto {
enum SceneStaticMesh_RenderPrimitiveEnum : int {
  SceneStaticMesh_RenderPrimitiveEnum_TRIANGLE_PRIMITIVE = 0,
  SceneStaticMesh_RenderPrimitiveEnum_POINT_PRIMITIVE = 1,
  SceneStaticMesh_RenderPrimitiveEnum_LINE_PRIMITIVE = 2,
  SceneStaticMesh_RenderPrimitiveEnum_SceneStaticMesh_RenderPrimitiveEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SceneStaticMesh_RenderPrimitiveEnum_SceneStaticMesh_RenderPrimitiveEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SceneStaticMesh_RenderPrimitiveEnum_IsValid(int value);
extern const uint32_t SceneStaticMesh_RenderPrimitiveEnum_internal_data_[];
constexpr SceneStaticMesh_RenderPrimitiveEnum SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MIN = static_cast<SceneStaticMesh_RenderPrimitiveEnum>(0);
constexpr SceneStaticMesh_RenderPrimitiveEnum SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MAX = static_cast<SceneStaticMesh_RenderPrimitiveEnum>(2);
constexpr int SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SceneStaticMesh_RenderPrimitiveEnum_descriptor();
template <typename T>
const std::string& SceneStaticMesh_RenderPrimitiveEnum_Name(T value) {
  static_assert(std::is_same<T, SceneStaticMesh_RenderPrimitiveEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RenderPrimitiveEnum_Name().");
  return SceneStaticMesh_RenderPrimitiveEnum_Name(static_cast<SceneStaticMesh_RenderPrimitiveEnum>(value));
}
template <>
inline const std::string& SceneStaticMesh_RenderPrimitiveEnum_Name(SceneStaticMesh_RenderPrimitiveEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SceneStaticMesh_RenderPrimitiveEnum_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SceneStaticMesh_RenderPrimitiveEnum_Parse(absl::string_view name, SceneStaticMesh_RenderPrimitiveEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneStaticMesh_RenderPrimitiveEnum>(
      SceneStaticMesh_RenderPrimitiveEnum_descriptor(), name, value);
}
enum SceneStaticMesh_MeshEnum : int {
  SceneStaticMesh_MeshEnum_INVALID = 0,
  SceneStaticMesh_MeshEnum_CUBE = 1,
  SceneStaticMesh_MeshEnum_QUAD = 2,
  SceneStaticMesh_MeshEnum_SceneStaticMesh_MeshEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SceneStaticMesh_MeshEnum_SceneStaticMesh_MeshEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SceneStaticMesh_MeshEnum_IsValid(int value);
extern const uint32_t SceneStaticMesh_MeshEnum_internal_data_[];
constexpr SceneStaticMesh_MeshEnum SceneStaticMesh_MeshEnum_MeshEnum_MIN = static_cast<SceneStaticMesh_MeshEnum>(0);
constexpr SceneStaticMesh_MeshEnum SceneStaticMesh_MeshEnum_MeshEnum_MAX = static_cast<SceneStaticMesh_MeshEnum>(2);
constexpr int SceneStaticMesh_MeshEnum_MeshEnum_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SceneStaticMesh_MeshEnum_descriptor();
template <typename T>
const std::string& SceneStaticMesh_MeshEnum_Name(T value) {
  static_assert(std::is_same<T, SceneStaticMesh_MeshEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to MeshEnum_Name().");
  return SceneStaticMesh_MeshEnum_Name(static_cast<SceneStaticMesh_MeshEnum>(value));
}
template <>
inline const std::string& SceneStaticMesh_MeshEnum_Name(SceneStaticMesh_MeshEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SceneStaticMesh_MeshEnum_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SceneStaticMesh_MeshEnum_Parse(absl::string_view name, SceneStaticMesh_MeshEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneStaticMesh_MeshEnum>(
      SceneStaticMesh_MeshEnum_descriptor(), name, value);
}
enum SceneStaticMesh_RenderTimeEnum : int {
  SceneStaticMesh_RenderTimeEnum_SCENE_RENDER_TIME = 0,
  SceneStaticMesh_RenderTimeEnum_PRE_RENDER_TIME = 1,
  SceneStaticMesh_RenderTimeEnum_POST_PROCESS_TIME = 2,
  SceneStaticMesh_RenderTimeEnum_SKYBOX_RENDER_TIME = 3,
  SceneStaticMesh_RenderTimeEnum_SHADOW_RENDER_TIME = 4,
  SceneStaticMesh_RenderTimeEnum_SceneStaticMesh_RenderTimeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SceneStaticMesh_RenderTimeEnum_SceneStaticMesh_RenderTimeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SceneStaticMesh_RenderTimeEnum_IsValid(int value);
extern const uint32_t SceneStaticMesh_RenderTimeEnum_internal_data_[];
constexpr SceneStaticMesh_RenderTimeEnum SceneStaticMesh_RenderTimeEnum_RenderTimeEnum_MIN = static_cast<SceneStaticMesh_RenderTimeEnum>(0);
constexpr SceneStaticMesh_RenderTimeEnum SceneStaticMesh_RenderTimeEnum_RenderTimeEnum_MAX = static_cast<SceneStaticMesh_RenderTimeEnum>(4);
constexpr int SceneStaticMesh_RenderTimeEnum_RenderTimeEnum_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
SceneStaticMesh_RenderTimeEnum_descriptor();
template <typename T>
const std::string& SceneStaticMesh_RenderTimeEnum_Name(T value) {
  static_assert(std::is_same<T, SceneStaticMesh_RenderTimeEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to RenderTimeEnum_Name().");
  return SceneStaticMesh_RenderTimeEnum_Name(static_cast<SceneStaticMesh_RenderTimeEnum>(value));
}
template <>
inline const std::string& SceneStaticMesh_RenderTimeEnum_Name(SceneStaticMesh_RenderTimeEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SceneStaticMesh_RenderTimeEnum_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SceneStaticMesh_RenderTimeEnum_Parse(absl::string_view name, SceneStaticMesh_RenderTimeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneStaticMesh_RenderTimeEnum>(
      SceneStaticMesh_RenderTimeEnum_descriptor(), name, value);
}
enum SceneStaticMesh_ShadowEffectEnum : int {
  SceneStaticMesh_ShadowEffectEnum_OPAQUE_SHADOW_EFFECT = 0,
  SceneStaticMesh_ShadowEffectEnum_TRANSPARENT_SHADOW_EFFECT = 1,
  SceneStaticMesh_ShadowEffectEnum_SceneStaticMesh_ShadowEffectEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SceneStaticMesh_ShadowEffectEnum_SceneStaticMesh_ShadowEffectEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SceneStaticMesh_ShadowEffectEnum_IsValid(int value);
extern const uint32_t SceneStaticMesh_ShadowEffectEnum_internal_data_[];
constexpr SceneStaticMesh_ShadowEffectEnum SceneStaticMesh_ShadowEffectEnum_ShadowEffectEnum_MIN = static_cast<SceneStaticMesh_ShadowEffectEnum>(0);
constexpr SceneStaticMesh_ShadowEffectEnum SceneStaticMesh_ShadowEffectEnum_ShadowEffectEnum_MAX = static_cast<SceneStaticMesh_ShadowEffectEnum>(1);
constexpr int SceneStaticMesh_ShadowEffectEnum_ShadowEffectEnum_ARRAYSIZE = 1 + 1;
const ::google::protobuf::EnumDescriptor*
SceneStaticMesh_ShadowEffectEnum_descriptor();
template <typename T>
const std::string& SceneStaticMesh_ShadowEffectEnum_Name(T value) {
  static_assert(std::is_same<T, SceneStaticMesh_ShadowEffectEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ShadowEffectEnum_Name().");
  return SceneStaticMesh_ShadowEffectEnum_Name(static_cast<SceneStaticMesh_ShadowEffectEnum>(value));
}
template <>
inline const std::string& SceneStaticMesh_ShadowEffectEnum_Name(SceneStaticMesh_ShadowEffectEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SceneStaticMesh_ShadowEffectEnum_descriptor,
                                                 0, 1>(
      static_cast<int>(value));
}
inline bool SceneStaticMesh_ShadowEffectEnum_Parse(absl::string_view name, SceneStaticMesh_ShadowEffectEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneStaticMesh_ShadowEffectEnum>(
      SceneStaticMesh_ShadowEffectEnum_descriptor(), name, value);
}
enum SceneLight_LightTypeEnum : int {
  SceneLight_LightTypeEnum_INVALID_LIGHT = 0,
  SceneLight_LightTypeEnum_AMBIENT_LIGHT = 1,
  SceneLight_LightTypeEnum_POINT_LIGHT = 2,
  SceneLight_LightTypeEnum_DIRECTIONAL_LIGHT = 3,
  SceneLight_LightTypeEnum_SPOT_LIGHT = 4,
  SceneLight_LightTypeEnum_SceneLight_LightTypeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SceneLight_LightTypeEnum_SceneLight_LightTypeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SceneLight_LightTypeEnum_IsValid(int value);
extern const uint32_t SceneLight_LightTypeEnum_internal_data_[];
constexpr SceneLight_LightTypeEnum SceneLight_LightTypeEnum_LightTypeEnum_MIN = static_cast<SceneLight_LightTypeEnum>(0);
constexpr SceneLight_LightTypeEnum SceneLight_LightTypeEnum_LightTypeEnum_MAX = static_cast<SceneLight_LightTypeEnum>(4);
constexpr int SceneLight_LightTypeEnum_LightTypeEnum_ARRAYSIZE = 4 + 1;
const ::google::protobuf::EnumDescriptor*
SceneLight_LightTypeEnum_descriptor();
template <typename T>
const std::string& SceneLight_LightTypeEnum_Name(T value) {
  static_assert(std::is_same<T, SceneLight_LightTypeEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to LightTypeEnum_Name().");
  return SceneLight_LightTypeEnum_Name(static_cast<SceneLight_LightTypeEnum>(value));
}
template <>
inline const std::string& SceneLight_LightTypeEnum_Name(SceneLight_LightTypeEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SceneLight_LightTypeEnum_descriptor,
                                                 0, 4>(
      static_cast<int>(value));
}
inline bool SceneLight_LightTypeEnum_Parse(absl::string_view name, SceneLight_LightTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneLight_LightTypeEnum>(
      SceneLight_LightTypeEnum_descriptor(), name, value);
}
enum SceneLight_ShadowTypeEnum : int {
  SceneLight_ShadowTypeEnum_NO_SHADOW = 0,
  SceneLight_ShadowTypeEnum_HARD_SHADOW = 1,
  SceneLight_ShadowTypeEnum_SOFT_SHADOW = 2,
  SceneLight_ShadowTypeEnum_SceneLight_ShadowTypeEnum_INT_MIN_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::min(),
  SceneLight_ShadowTypeEnum_SceneLight_ShadowTypeEnum_INT_MAX_SENTINEL_DO_NOT_USE_ =
      std::numeric_limits<::int32_t>::max(),
};

bool SceneLight_ShadowTypeEnum_IsValid(int value);
extern const uint32_t SceneLight_ShadowTypeEnum_internal_data_[];
constexpr SceneLight_ShadowTypeEnum SceneLight_ShadowTypeEnum_ShadowTypeEnum_MIN = static_cast<SceneLight_ShadowTypeEnum>(0);
constexpr SceneLight_ShadowTypeEnum SceneLight_ShadowTypeEnum_ShadowTypeEnum_MAX = static_cast<SceneLight_ShadowTypeEnum>(2);
constexpr int SceneLight_ShadowTypeEnum_ShadowTypeEnum_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor*
SceneLight_ShadowTypeEnum_descriptor();
template <typename T>
const std::string& SceneLight_ShadowTypeEnum_Name(T value) {
  static_assert(std::is_same<T, SceneLight_ShadowTypeEnum>::value ||
                    std::is_integral<T>::value,
                "Incorrect type passed to ShadowTypeEnum_Name().");
  return SceneLight_ShadowTypeEnum_Name(static_cast<SceneLight_ShadowTypeEnum>(value));
}
template <>
inline const std::string& SceneLight_ShadowTypeEnum_Name(SceneLight_ShadowTypeEnum value) {
  return ::google::protobuf::internal::NameOfDenseEnum<SceneLight_ShadowTypeEnum_descriptor,
                                                 0, 2>(
      static_cast<int>(value));
}
inline bool SceneLight_ShadowTypeEnum_Parse(absl::string_view name, SceneLight_ShadowTypeEnum* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SceneLight_ShadowTypeEnum>(
      SceneLight_ShadowTypeEnum_descriptor(), name, value);
}

// ===================================================================


// -------------------------------------------------------------------

class SceneMatrix final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:frame.proto.SceneMatrix) */ {
 public:
  inline SceneMatrix() : SceneMatrix(nullptr) {}
  ~SceneMatrix() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SceneMatrix(::google::protobuf::internal::ConstantInitialized);

  inline SceneMatrix(const SceneMatrix& from)
      : SceneMatrix(nullptr, from) {}
  SceneMatrix(SceneMatrix&& from) noexcept
    : SceneMatrix() {
    *this = ::std::move(from);
  }

  inline SceneMatrix& operator=(const SceneMatrix& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneMatrix& operator=(SceneMatrix&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneMatrix& default_instance() {
    return *internal_default_instance();
  }
  static inline const SceneMatrix* internal_default_instance() {
    return reinterpret_cast<const SceneMatrix*>(
               &_SceneMatrix_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(SceneMatrix& a, SceneMatrix& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneMatrix* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneMatrix* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneMatrix* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SceneMatrix>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SceneMatrix& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SceneMatrix& from) {
    SceneMatrix::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SceneMatrix* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "frame.proto.SceneMatrix";
  }
  protected:
  explicit SceneMatrix(::google::protobuf::Arena* arena);
  SceneMatrix(::google::protobuf::Arena* arena, const SceneMatrix& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kMatrixFieldNumber = 3,
    kQuaternionFieldNumber = 4,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string parent = 2;
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // .frame.proto.UniformMatrix4 matrix = 3;
  bool has_matrix() const;
  void clear_matrix() ;
  const ::frame::proto::UniformMatrix4& matrix() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformMatrix4* release_matrix();
  ::frame::proto::UniformMatrix4* mutable_matrix();
  void set_allocated_matrix(::frame::proto::UniformMatrix4* value);
  void unsafe_arena_set_allocated_matrix(::frame::proto::UniformMatrix4* value);
  ::frame::proto::UniformMatrix4* unsafe_arena_release_matrix();

  private:
  const ::frame::proto::UniformMatrix4& _internal_matrix() const;
  ::frame::proto::UniformMatrix4* _internal_mutable_matrix();

  public:
  // .frame.proto.UniformQuaternion quaternion = 4;
  bool has_quaternion() const;
  void clear_quaternion() ;
  const ::frame::proto::UniformQuaternion& quaternion() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformQuaternion* release_quaternion();
  ::frame::proto::UniformQuaternion* mutable_quaternion();
  void set_allocated_quaternion(::frame::proto::UniformQuaternion* value);
  void unsafe_arena_set_allocated_quaternion(::frame::proto::UniformQuaternion* value);
  ::frame::proto::UniformQuaternion* unsafe_arena_release_quaternion();

  private:
  const ::frame::proto::UniformQuaternion& _internal_quaternion() const;
  ::frame::proto::UniformQuaternion* _internal_mutable_quaternion();

  public:
  // @@protoc_insertion_point(class_scope:frame.proto.SceneMatrix)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      2, 4, 2,
      42, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    ::frame::proto::UniformMatrix4* matrix_;
    ::frame::proto::UniformQuaternion* quaternion_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};// -------------------------------------------------------------------

class SceneLight final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:frame.proto.SceneLight) */ {
 public:
  inline SceneLight() : SceneLight(nullptr) {}
  ~SceneLight() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SceneLight(::google::protobuf::internal::ConstantInitialized);

  inline SceneLight(const SceneLight& from)
      : SceneLight(nullptr, from) {}
  SceneLight(SceneLight&& from) noexcept
    : SceneLight() {
    *this = ::std::move(from);
  }

  inline SceneLight& operator=(const SceneLight& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneLight& operator=(SceneLight&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneLight& default_instance() {
    return *internal_default_instance();
  }
  static inline const SceneLight* internal_default_instance() {
    return reinterpret_cast<const SceneLight*>(
               &_SceneLight_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(SceneLight& a, SceneLight& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneLight* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneLight* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneLight* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SceneLight>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SceneLight& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SceneLight& from) {
    SceneLight::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SceneLight* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "frame.proto.SceneLight";
  }
  protected:
  explicit SceneLight(::google::protobuf::Arena* arena);
  SceneLight(::google::protobuf::Arena* arena, const SceneLight& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using LightTypeEnum = SceneLight_LightTypeEnum;
  static constexpr LightTypeEnum INVALID_LIGHT = SceneLight_LightTypeEnum_INVALID_LIGHT;
  static constexpr LightTypeEnum AMBIENT_LIGHT = SceneLight_LightTypeEnum_AMBIENT_LIGHT;
  static constexpr LightTypeEnum POINT_LIGHT = SceneLight_LightTypeEnum_POINT_LIGHT;
  static constexpr LightTypeEnum DIRECTIONAL_LIGHT = SceneLight_LightTypeEnum_DIRECTIONAL_LIGHT;
  static constexpr LightTypeEnum SPOT_LIGHT = SceneLight_LightTypeEnum_SPOT_LIGHT;
  static inline bool LightTypeEnum_IsValid(int value) {
    return SceneLight_LightTypeEnum_IsValid(value);
  }
  static constexpr LightTypeEnum LightTypeEnum_MIN = SceneLight_LightTypeEnum_LightTypeEnum_MIN;
  static constexpr LightTypeEnum LightTypeEnum_MAX = SceneLight_LightTypeEnum_LightTypeEnum_MAX;
  static constexpr int LightTypeEnum_ARRAYSIZE = SceneLight_LightTypeEnum_LightTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* LightTypeEnum_descriptor() {
    return SceneLight_LightTypeEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& LightTypeEnum_Name(T value) {
    return SceneLight_LightTypeEnum_Name(value);
  }
  static inline bool LightTypeEnum_Parse(absl::string_view name, LightTypeEnum* value) {
    return SceneLight_LightTypeEnum_Parse(name, value);
  }

  using ShadowTypeEnum = SceneLight_ShadowTypeEnum;
  static constexpr ShadowTypeEnum NO_SHADOW = SceneLight_ShadowTypeEnum_NO_SHADOW;
  static constexpr ShadowTypeEnum HARD_SHADOW = SceneLight_ShadowTypeEnum_HARD_SHADOW;
  static constexpr ShadowTypeEnum SOFT_SHADOW = SceneLight_ShadowTypeEnum_SOFT_SHADOW;
  static inline bool ShadowTypeEnum_IsValid(int value) {
    return SceneLight_ShadowTypeEnum_IsValid(value);
  }
  static constexpr ShadowTypeEnum ShadowTypeEnum_MIN = SceneLight_ShadowTypeEnum_ShadowTypeEnum_MIN;
  static constexpr ShadowTypeEnum ShadowTypeEnum_MAX = SceneLight_ShadowTypeEnum_ShadowTypeEnum_MAX;
  static constexpr int ShadowTypeEnum_ARRAYSIZE = SceneLight_ShadowTypeEnum_ShadowTypeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ShadowTypeEnum_descriptor() {
    return SceneLight_ShadowTypeEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& ShadowTypeEnum_Name(T value) {
    return SceneLight_ShadowTypeEnum_Name(value);
  }
  static inline bool ShadowTypeEnum_Parse(absl::string_view name, ShadowTypeEnum* value) {
    return SceneLight_ShadowTypeEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kShadowTextureFieldNumber = 10,
    kPositionFieldNumber = 4,
    kDirectionFieldNumber = 5,
    kColorFieldNumber = 8,
    kLightTypeFieldNumber = 3,
    kDotInnerLimitFieldNumber = 6,
    kDotOuterLimitFieldNumber = 7,
    kShadowTypeFieldNumber = 9,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string parent = 2;
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // string shadow_texture = 10;
  void clear_shadow_texture() ;
  const std::string& shadow_texture() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_shadow_texture(Arg_&& arg, Args_... args);
  std::string* mutable_shadow_texture();
  PROTOBUF_NODISCARD std::string* release_shadow_texture();
  void set_allocated_shadow_texture(std::string* value);

  private:
  const std::string& _internal_shadow_texture() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_shadow_texture(
      const std::string& value);
  std::string* _internal_mutable_shadow_texture();

  public:
  // .frame.proto.UniformVector3 position = 4;
  bool has_position() const;
  void clear_position() ;
  const ::frame::proto::UniformVector3& position() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_position();
  ::frame::proto::UniformVector3* mutable_position();
  void set_allocated_position(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_position(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_position();

  private:
  const ::frame::proto::UniformVector3& _internal_position() const;
  ::frame::proto::UniformVector3* _internal_mutable_position();

  public:
  // .frame.proto.UniformVector3 direction = 5;
  bool has_direction() const;
  void clear_direction() ;
  const ::frame::proto::UniformVector3& direction() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_direction();
  ::frame::proto::UniformVector3* mutable_direction();
  void set_allocated_direction(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_direction(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_direction();

  private:
  const ::frame::proto::UniformVector3& _internal_direction() const;
  ::frame::proto::UniformVector3* _internal_mutable_direction();

  public:
  // .frame.proto.UniformVector3 color = 8;
  bool has_color() const;
  void clear_color() ;
  const ::frame::proto::UniformVector3& color() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_color();
  ::frame::proto::UniformVector3* mutable_color();
  void set_allocated_color(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_color(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_color();

  private:
  const ::frame::proto::UniformVector3& _internal_color() const;
  ::frame::proto::UniformVector3* _internal_mutable_color();

  public:
  // .frame.proto.SceneLight.LightTypeEnum light_type = 3;
  void clear_light_type() ;
  ::frame::proto::SceneLight_LightTypeEnum light_type() const;
  void set_light_type(::frame::proto::SceneLight_LightTypeEnum value);

  private:
  ::frame::proto::SceneLight_LightTypeEnum _internal_light_type() const;
  void _internal_set_light_type(::frame::proto::SceneLight_LightTypeEnum value);

  public:
  // float dot_inner_limit = 6;
  void clear_dot_inner_limit() ;
  float dot_inner_limit() const;
  void set_dot_inner_limit(float value);

  private:
  float _internal_dot_inner_limit() const;
  void _internal_set_dot_inner_limit(float value);

  public:
  // float dot_outer_limit = 7;
  void clear_dot_outer_limit() ;
  float dot_outer_limit() const;
  void set_dot_outer_limit(float value);

  private:
  float _internal_dot_outer_limit() const;
  void _internal_set_dot_outer_limit(float value);

  public:
  // .frame.proto.SceneLight.ShadowTypeEnum shadow_type = 9;
  void clear_shadow_type() ;
  ::frame::proto::SceneLight_ShadowTypeEnum shadow_type() const;
  void set_shadow_type(::frame::proto::SceneLight_ShadowTypeEnum value);

  private:
  ::frame::proto::SceneLight_ShadowTypeEnum _internal_shadow_type() const;
  void _internal_set_shadow_type(::frame::proto::SceneLight_ShadowTypeEnum value);

  public:
  // @@protoc_insertion_point(class_scope:frame.proto.SceneLight)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 10, 3,
      63, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    ::google::protobuf::internal::ArenaStringPtr shadow_texture_;
    ::frame::proto::UniformVector3* position_;
    ::frame::proto::UniformVector3* direction_;
    ::frame::proto::UniformVector3* color_;
    int light_type_;
    float dot_inner_limit_;
    float dot_outer_limit_;
    int shadow_type_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};// -------------------------------------------------------------------

class SceneCamera final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:frame.proto.SceneCamera) */ {
 public:
  inline SceneCamera() : SceneCamera(nullptr) {}
  ~SceneCamera() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SceneCamera(::google::protobuf::internal::ConstantInitialized);

  inline SceneCamera(const SceneCamera& from)
      : SceneCamera(nullptr, from) {}
  SceneCamera(SceneCamera&& from) noexcept
    : SceneCamera() {
    *this = ::std::move(from);
  }

  inline SceneCamera& operator=(const SceneCamera& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneCamera& operator=(SceneCamera&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneCamera& default_instance() {
    return *internal_default_instance();
  }
  static inline const SceneCamera* internal_default_instance() {
    return reinterpret_cast<const SceneCamera*>(
               &_SceneCamera_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(SceneCamera& a, SceneCamera& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneCamera* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneCamera* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneCamera* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SceneCamera>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SceneCamera& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SceneCamera& from) {
    SceneCamera::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SceneCamera* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "frame.proto.SceneCamera";
  }
  protected:
  explicit SceneCamera(::google::protobuf::Arena* arena);
  SceneCamera(::google::protobuf::Arena* arena, const SceneCamera& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kPositionFieldNumber = 3,
    kTargetFieldNumber = 4,
    kUpFieldNumber = 5,
    kFovDegreesFieldNumber = 6,
    kAspectRatioFieldNumber = 7,
    kNearClipFieldNumber = 8,
    kFarClipFieldNumber = 9,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string parent = 2;
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // .frame.proto.UniformVector3 position = 3;
  bool has_position() const;
  void clear_position() ;
  const ::frame::proto::UniformVector3& position() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_position();
  ::frame::proto::UniformVector3* mutable_position();
  void set_allocated_position(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_position(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_position();

  private:
  const ::frame::proto::UniformVector3& _internal_position() const;
  ::frame::proto::UniformVector3* _internal_mutable_position();

  public:
  // .frame.proto.UniformVector3 target = 4;
  bool has_target() const;
  void clear_target() ;
  const ::frame::proto::UniformVector3& target() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_target();
  ::frame::proto::UniformVector3* mutable_target();
  void set_allocated_target(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_target(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_target();

  private:
  const ::frame::proto::UniformVector3& _internal_target() const;
  ::frame::proto::UniformVector3* _internal_mutable_target();

  public:
  // .frame.proto.UniformVector3 up = 5;
  bool has_up() const;
  void clear_up() ;
  const ::frame::proto::UniformVector3& up() const;
  PROTOBUF_NODISCARD ::frame::proto::UniformVector3* release_up();
  ::frame::proto::UniformVector3* mutable_up();
  void set_allocated_up(::frame::proto::UniformVector3* value);
  void unsafe_arena_set_allocated_up(::frame::proto::UniformVector3* value);
  ::frame::proto::UniformVector3* unsafe_arena_release_up();

  private:
  const ::frame::proto::UniformVector3& _internal_up() const;
  ::frame::proto::UniformVector3* _internal_mutable_up();

  public:
  // float fov_degrees = 6;
  void clear_fov_degrees() ;
  float fov_degrees() const;
  void set_fov_degrees(float value);

  private:
  float _internal_fov_degrees() const;
  void _internal_set_fov_degrees(float value);

  public:
  // float aspect_ratio = 7;
  void clear_aspect_ratio() ;
  float aspect_ratio() const;
  void set_aspect_ratio(float value);

  private:
  float _internal_aspect_ratio() const;
  void _internal_set_aspect_ratio(float value);

  public:
  // float near_clip = 8;
  void clear_near_clip() ;
  float near_clip() const;
  void set_near_clip(float value);

  private:
  float _internal_near_clip() const;
  void _internal_set_near_clip(float value);

  public:
  // float far_clip = 9;
  void clear_far_clip() ;
  float far_clip() const;
  void set_far_clip(float value);

  private:
  float _internal_far_clip() const;
  void _internal_set_far_clip(float value);

  public:
  // @@protoc_insertion_point(class_scope:frame.proto.SceneCamera)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      4, 9, 3,
      50, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::HasBits<1> _has_bits_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    ::frame::proto::UniformVector3* position_;
    ::frame::proto::UniformVector3* target_;
    ::frame::proto::UniformVector3* up_;
    float fov_degrees_;
    float aspect_ratio_;
    float near_clip_;
    float far_clip_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};// -------------------------------------------------------------------

class SceneStaticMesh final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:frame.proto.SceneStaticMesh) */ {
 public:
  inline SceneStaticMesh() : SceneStaticMesh(nullptr) {}
  ~SceneStaticMesh() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SceneStaticMesh(::google::protobuf::internal::ConstantInitialized);

  inline SceneStaticMesh(const SceneStaticMesh& from)
      : SceneStaticMesh(nullptr, from) {}
  SceneStaticMesh(SceneStaticMesh&& from) noexcept
    : SceneStaticMesh() {
    *this = ::std::move(from);
  }

  inline SceneStaticMesh& operator=(const SceneStaticMesh& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneStaticMesh& operator=(SceneStaticMesh&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneStaticMesh& default_instance() {
    return *internal_default_instance();
  }
  enum MeshOneofCase {
    kCleanBuffer = 7,
    kMeshEnum = 6,
    kFileName = 3,
    kMultiPlugin = 10,
    MESH_ONEOF_NOT_SET = 0,
  };

  static inline const SceneStaticMesh* internal_default_instance() {
    return reinterpret_cast<const SceneStaticMesh*>(
               &_SceneStaticMesh_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SceneStaticMesh& a, SceneStaticMesh& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneStaticMesh* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneStaticMesh* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneStaticMesh* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SceneStaticMesh>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SceneStaticMesh& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SceneStaticMesh& from) {
    SceneStaticMesh::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SceneStaticMesh* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "frame.proto.SceneStaticMesh";
  }
  protected:
  explicit SceneStaticMesh(::google::protobuf::Arena* arena);
  SceneStaticMesh(::google::protobuf::Arena* arena, const SceneStaticMesh& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  using RenderPrimitiveEnum = SceneStaticMesh_RenderPrimitiveEnum;
  static constexpr RenderPrimitiveEnum TRIANGLE_PRIMITIVE = SceneStaticMesh_RenderPrimitiveEnum_TRIANGLE_PRIMITIVE;
  static constexpr RenderPrimitiveEnum POINT_PRIMITIVE = SceneStaticMesh_RenderPrimitiveEnum_POINT_PRIMITIVE;
  static constexpr RenderPrimitiveEnum LINE_PRIMITIVE = SceneStaticMesh_RenderPrimitiveEnum_LINE_PRIMITIVE;
  static inline bool RenderPrimitiveEnum_IsValid(int value) {
    return SceneStaticMesh_RenderPrimitiveEnum_IsValid(value);
  }
  static constexpr RenderPrimitiveEnum RenderPrimitiveEnum_MIN = SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MIN;
  static constexpr RenderPrimitiveEnum RenderPrimitiveEnum_MAX = SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_MAX;
  static constexpr int RenderPrimitiveEnum_ARRAYSIZE = SceneStaticMesh_RenderPrimitiveEnum_RenderPrimitiveEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RenderPrimitiveEnum_descriptor() {
    return SceneStaticMesh_RenderPrimitiveEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& RenderPrimitiveEnum_Name(T value) {
    return SceneStaticMesh_RenderPrimitiveEnum_Name(value);
  }
  static inline bool RenderPrimitiveEnum_Parse(absl::string_view name, RenderPrimitiveEnum* value) {
    return SceneStaticMesh_RenderPrimitiveEnum_Parse(name, value);
  }

  using MeshEnum = SceneStaticMesh_MeshEnum;
  static constexpr MeshEnum INVALID = SceneStaticMesh_MeshEnum_INVALID;
  static constexpr MeshEnum CUBE = SceneStaticMesh_MeshEnum_CUBE;
  static constexpr MeshEnum QUAD = SceneStaticMesh_MeshEnum_QUAD;
  static inline bool MeshEnum_IsValid(int value) {
    return SceneStaticMesh_MeshEnum_IsValid(value);
  }
  static constexpr MeshEnum MeshEnum_MIN = SceneStaticMesh_MeshEnum_MeshEnum_MIN;
  static constexpr MeshEnum MeshEnum_MAX = SceneStaticMesh_MeshEnum_MeshEnum_MAX;
  static constexpr int MeshEnum_ARRAYSIZE = SceneStaticMesh_MeshEnum_MeshEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* MeshEnum_descriptor() {
    return SceneStaticMesh_MeshEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& MeshEnum_Name(T value) {
    return SceneStaticMesh_MeshEnum_Name(value);
  }
  static inline bool MeshEnum_Parse(absl::string_view name, MeshEnum* value) {
    return SceneStaticMesh_MeshEnum_Parse(name, value);
  }

  using RenderTimeEnum = SceneStaticMesh_RenderTimeEnum;
  static constexpr RenderTimeEnum SCENE_RENDER_TIME = SceneStaticMesh_RenderTimeEnum_SCENE_RENDER_TIME;
  static constexpr RenderTimeEnum PRE_RENDER_TIME = SceneStaticMesh_RenderTimeEnum_PRE_RENDER_TIME;
  static constexpr RenderTimeEnum POST_PROCESS_TIME = SceneStaticMesh_RenderTimeEnum_POST_PROCESS_TIME;
  static constexpr RenderTimeEnum SKYBOX_RENDER_TIME = SceneStaticMesh_RenderTimeEnum_SKYBOX_RENDER_TIME;
  static constexpr RenderTimeEnum SHADOW_RENDER_TIME = SceneStaticMesh_RenderTimeEnum_SHADOW_RENDER_TIME;
  static inline bool RenderTimeEnum_IsValid(int value) {
    return SceneStaticMesh_RenderTimeEnum_IsValid(value);
  }
  static constexpr RenderTimeEnum RenderTimeEnum_MIN = SceneStaticMesh_RenderTimeEnum_RenderTimeEnum_MIN;
  static constexpr RenderTimeEnum RenderTimeEnum_MAX = SceneStaticMesh_RenderTimeEnum_RenderTimeEnum_MAX;
  static constexpr int RenderTimeEnum_ARRAYSIZE = SceneStaticMesh_RenderTimeEnum_RenderTimeEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* RenderTimeEnum_descriptor() {
    return SceneStaticMesh_RenderTimeEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& RenderTimeEnum_Name(T value) {
    return SceneStaticMesh_RenderTimeEnum_Name(value);
  }
  static inline bool RenderTimeEnum_Parse(absl::string_view name, RenderTimeEnum* value) {
    return SceneStaticMesh_RenderTimeEnum_Parse(name, value);
  }

  using ShadowEffectEnum = SceneStaticMesh_ShadowEffectEnum;
  static constexpr ShadowEffectEnum OPAQUE_SHADOW_EFFECT = SceneStaticMesh_ShadowEffectEnum_OPAQUE_SHADOW_EFFECT;
  static constexpr ShadowEffectEnum TRANSPARENT_SHADOW_EFFECT = SceneStaticMesh_ShadowEffectEnum_TRANSPARENT_SHADOW_EFFECT;
  static inline bool ShadowEffectEnum_IsValid(int value) {
    return SceneStaticMesh_ShadowEffectEnum_IsValid(value);
  }
  static constexpr ShadowEffectEnum ShadowEffectEnum_MIN = SceneStaticMesh_ShadowEffectEnum_ShadowEffectEnum_MIN;
  static constexpr ShadowEffectEnum ShadowEffectEnum_MAX = SceneStaticMesh_ShadowEffectEnum_ShadowEffectEnum_MAX;
  static constexpr int ShadowEffectEnum_ARRAYSIZE = SceneStaticMesh_ShadowEffectEnum_ShadowEffectEnum_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor* ShadowEffectEnum_descriptor() {
    return SceneStaticMesh_ShadowEffectEnum_descriptor();
  }
  template <typename T>
  static inline const std::string& ShadowEffectEnum_Name(T value) {
    return SceneStaticMesh_ShadowEffectEnum_Name(value);
  }
  static inline bool ShadowEffectEnum_Parse(absl::string_view name, ShadowEffectEnum* value) {
    return SceneStaticMesh_ShadowEffectEnum_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kParentFieldNumber = 2,
    kMaterialNameFieldNumber = 5,
    kRenderPrimitiveEnumFieldNumber = 8,
    kRenderTimeEnumFieldNumber = 11,
    kShadowEffectEnumFieldNumber = 12,
    kCleanBufferFieldNumber = 7,
    kMeshEnumFieldNumber = 6,
    kFileNameFieldNumber = 3,
    kMultiPluginFieldNumber = 10,
  };
  // string name = 1;
  void clear_name() ;
  const std::string& name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_name(Arg_&& arg, Args_... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* value);

  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(
      const std::string& value);
  std::string* _internal_mutable_name();

  public:
  // string parent = 2;
  void clear_parent() ;
  const std::string& parent() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_parent(Arg_&& arg, Args_... args);
  std::string* mutable_parent();
  PROTOBUF_NODISCARD std::string* release_parent();
  void set_allocated_parent(std::string* value);

  private:
  const std::string& _internal_parent() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent(
      const std::string& value);
  std::string* _internal_mutable_parent();

  public:
  // string material_name = 5;
  void clear_material_name() ;
  const std::string& material_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_material_name(Arg_&& arg, Args_... args);
  std::string* mutable_material_name();
  PROTOBUF_NODISCARD std::string* release_material_name();
  void set_allocated_material_name(std::string* value);

  private:
  const std::string& _internal_material_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_material_name(
      const std::string& value);
  std::string* _internal_mutable_material_name();

  public:
  // .frame.proto.SceneStaticMesh.RenderPrimitiveEnum render_primitive_enum = 8;
  void clear_render_primitive_enum() ;
  ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum render_primitive_enum() const;
  void set_render_primitive_enum(::frame::proto::SceneStaticMesh_RenderPrimitiveEnum value);

  private:
  ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum _internal_render_primitive_enum() const;
  void _internal_set_render_primitive_enum(::frame::proto::SceneStaticMesh_RenderPrimitiveEnum value);

  public:
  // .frame.proto.SceneStaticMesh.RenderTimeEnum render_time_enum = 11;
  void clear_render_time_enum() ;
  ::frame::proto::SceneStaticMesh_RenderTimeEnum render_time_enum() const;
  void set_render_time_enum(::frame::proto::SceneStaticMesh_RenderTimeEnum value);

  private:
  ::frame::proto::SceneStaticMesh_RenderTimeEnum _internal_render_time_enum() const;
  void _internal_set_render_time_enum(::frame::proto::SceneStaticMesh_RenderTimeEnum value);

  public:
  // .frame.proto.SceneStaticMesh.ShadowEffectEnum shadow_effect_enum = 12;
  void clear_shadow_effect_enum() ;
  ::frame::proto::SceneStaticMesh_ShadowEffectEnum shadow_effect_enum() const;
  void set_shadow_effect_enum(::frame::proto::SceneStaticMesh_ShadowEffectEnum value);

  private:
  ::frame::proto::SceneStaticMesh_ShadowEffectEnum _internal_shadow_effect_enum() const;
  void _internal_set_shadow_effect_enum(::frame::proto::SceneStaticMesh_ShadowEffectEnum value);

  public:
  // .frame.proto.CleanBuffer clean_buffer = 7;
  bool has_clean_buffer() const;
  private:
  bool _internal_has_clean_buffer() const;

  public:
  void clear_clean_buffer() ;
  const ::frame::proto::CleanBuffer& clean_buffer() const;
  PROTOBUF_NODISCARD ::frame::proto::CleanBuffer* release_clean_buffer();
  ::frame::proto::CleanBuffer* mutable_clean_buffer();
  void set_allocated_clean_buffer(::frame::proto::CleanBuffer* value);
  void unsafe_arena_set_allocated_clean_buffer(::frame::proto::CleanBuffer* value);
  ::frame::proto::CleanBuffer* unsafe_arena_release_clean_buffer();

  private:
  const ::frame::proto::CleanBuffer& _internal_clean_buffer() const;
  ::frame::proto::CleanBuffer* _internal_mutable_clean_buffer();

  public:
  // .frame.proto.SceneStaticMesh.MeshEnum mesh_enum = 6;
  bool has_mesh_enum() const;
  void clear_mesh_enum() ;
  ::frame::proto::SceneStaticMesh_MeshEnum mesh_enum() const;
  void set_mesh_enum(::frame::proto::SceneStaticMesh_MeshEnum value);

  private:
  ::frame::proto::SceneStaticMesh_MeshEnum _internal_mesh_enum() const;
  void _internal_set_mesh_enum(::frame::proto::SceneStaticMesh_MeshEnum value);

  public:
  // string file_name = 3;
  bool has_file_name() const;
  void clear_file_name() ;
  const std::string& file_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_file_name(Arg_&& arg, Args_... args);
  std::string* mutable_file_name();
  PROTOBUF_NODISCARD std::string* release_file_name();
  void set_allocated_file_name(std::string* value);

  private:
  const std::string& _internal_file_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_file_name(
      const std::string& value);
  std::string* _internal_mutable_file_name();

  public:
  // .frame.proto.MultiPlugin multi_plugin = 10;
  bool has_multi_plugin() const;
  private:
  bool _internal_has_multi_plugin() const;

  public:
  void clear_multi_plugin() ;
  const ::frame::proto::MultiPlugin& multi_plugin() const;
  PROTOBUF_NODISCARD ::frame::proto::MultiPlugin* release_multi_plugin();
  ::frame::proto::MultiPlugin* mutable_multi_plugin();
  void set_allocated_multi_plugin(::frame::proto::MultiPlugin* value);
  void unsafe_arena_set_allocated_multi_plugin(::frame::proto::MultiPlugin* value);
  ::frame::proto::MultiPlugin* unsafe_arena_release_multi_plugin();

  private:
  const ::frame::proto::MultiPlugin& _internal_multi_plugin() const;
  ::frame::proto::MultiPlugin* _internal_mutable_multi_plugin();

  public:
  void clear_mesh_oneof();
  MeshOneofCase mesh_oneof_case() const;
  // @@protoc_insertion_point(class_scope:frame.proto.SceneStaticMesh)
 private:
  class _Internal;
  void set_has_clean_buffer();
  void set_has_mesh_enum();
  void set_has_file_name();
  void set_has_multi_plugin();

  inline bool has_mesh_oneof() const;
  inline void clear_has_mesh_oneof();

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 10, 2,
      76, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::internal::ArenaStringPtr name_;
    ::google::protobuf::internal::ArenaStringPtr parent_;
    ::google::protobuf::internal::ArenaStringPtr material_name_;
    int render_primitive_enum_;
    int render_time_enum_;
    int shadow_effect_enum_;
    union MeshOneofUnion {
      constexpr MeshOneofUnion() : _constinit_{} {}
        ::google::protobuf::internal::ConstantInitialized _constinit_;
      ::frame::proto::CleanBuffer* clean_buffer_;
      int mesh_enum_;
      ::google::protobuf::internal::ArenaStringPtr file_name_;
      ::frame::proto::MultiPlugin* multi_plugin_;
    } mesh_oneof_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    ::uint32_t _oneof_case_[1];

    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};// -------------------------------------------------------------------

class SceneTree final :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:frame.proto.SceneTree) */ {
 public:
  inline SceneTree() : SceneTree(nullptr) {}
  ~SceneTree() override;
  template<typename = void>
  explicit PROTOBUF_CONSTEXPR SceneTree(::google::protobuf::internal::ConstantInitialized);

  inline SceneTree(const SceneTree& from)
      : SceneTree(nullptr, from) {}
  SceneTree(SceneTree&& from) noexcept
    : SceneTree() {
    *this = ::std::move(from);
  }

  inline SceneTree& operator=(const SceneTree& from) {
    CopyFrom(from);
    return *this;
  }
  inline SceneTree& operator=(SceneTree&& from) noexcept {
    if (this == &from) return *this;
    if (GetArena() == from.GetArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.unknown_fields<::google::protobuf::UnknownFieldSet>(::google::protobuf::UnknownFieldSet::default_instance);
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
      ABSL_ATTRIBUTE_LIFETIME_BOUND {
    return _internal_metadata_.mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::google::protobuf::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::google::protobuf::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SceneTree& default_instance() {
    return *internal_default_instance();
  }
  static inline const SceneTree* internal_default_instance() {
    return reinterpret_cast<const SceneTree*>(
               &_SceneTree_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(SceneTree& a, SceneTree& b) {
    a.Swap(&b);
  }
  inline void Swap(SceneTree* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() != nullptr &&
        GetArena() == other->GetArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetArena() == other->GetArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::google::protobuf::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SceneTree* other) {
    if (other == this) return;
    ABSL_DCHECK(GetArena() == other->GetArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SceneTree* New(::google::protobuf::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SceneTree>(arena);
  }
  using ::google::protobuf::Message::CopyFrom;
  void CopyFrom(const SceneTree& from);
  using ::google::protobuf::Message::MergeFrom;
  void MergeFrom( const SceneTree& from) {
    SceneTree::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::google::protobuf::Message& to_msg, const ::google::protobuf::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  ::size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::google::protobuf::internal::ParseContext* ctx) final;
  ::uint8_t* _InternalSerialize(
      ::uint8_t* target, ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const { return _impl_._cached_size_.Get(); }

  private:
  ::google::protobuf::internal::CachedSize* AccessCachedSize() const final;
  void SharedCtor(::google::protobuf::Arena* arena);
  void SharedDtor();
  void InternalSwap(SceneTree* other);

  private:
  friend class ::google::protobuf::internal::AnyMetadata;
  static ::absl::string_view FullMessageName() {
    return "frame.proto.SceneTree";
  }
  protected:
  explicit SceneTree(::google::protobuf::Arena* arena);
  SceneTree(::google::protobuf::Arena* arena, const SceneTree& from);
  public:

  static const ClassData _class_data_;
  const ::google::protobuf::Message::ClassData*GetClassData() const final;

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSceneMatricesFieldNumber = 3,
    kSceneStaticMeshesFieldNumber = 4,
    kSceneCamerasFieldNumber = 5,
    kSceneLightsFieldNumber = 6,
    kDefaultRootNameFieldNumber = 1,
    kDefaultCameraNameFieldNumber = 2,
  };
  // repeated .frame.proto.SceneMatrix scene_matrices = 3;
  int scene_matrices_size() const;
  private:
  int _internal_scene_matrices_size() const;

  public:
  void clear_scene_matrices() ;
  ::frame::proto::SceneMatrix* mutable_scene_matrices(int index);
  ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneMatrix >*
      mutable_scene_matrices();
  private:
  const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneMatrix>& _internal_scene_matrices() const;
  ::google::protobuf::RepeatedPtrField<::frame::proto::SceneMatrix>* _internal_mutable_scene_matrices();
  public:
  const ::frame::proto::SceneMatrix& scene_matrices(int index) const;
  ::frame::proto::SceneMatrix* add_scene_matrices();
  const ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneMatrix >&
      scene_matrices() const;
  // repeated .frame.proto.SceneStaticMesh scene_static_meshes = 4;
  int scene_static_meshes_size() const;
  private:
  int _internal_scene_static_meshes_size() const;

  public:
  void clear_scene_static_meshes() ;
  ::frame::proto::SceneStaticMesh* mutable_scene_static_meshes(int index);
  ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneStaticMesh >*
      mutable_scene_static_meshes();
  private:
  const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneStaticMesh>& _internal_scene_static_meshes() const;
  ::google::protobuf::RepeatedPtrField<::frame::proto::SceneStaticMesh>* _internal_mutable_scene_static_meshes();
  public:
  const ::frame::proto::SceneStaticMesh& scene_static_meshes(int index) const;
  ::frame::proto::SceneStaticMesh* add_scene_static_meshes();
  const ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneStaticMesh >&
      scene_static_meshes() const;
  // repeated .frame.proto.SceneCamera scene_cameras = 5;
  int scene_cameras_size() const;
  private:
  int _internal_scene_cameras_size() const;

  public:
  void clear_scene_cameras() ;
  ::frame::proto::SceneCamera* mutable_scene_cameras(int index);
  ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneCamera >*
      mutable_scene_cameras();
  private:
  const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneCamera>& _internal_scene_cameras() const;
  ::google::protobuf::RepeatedPtrField<::frame::proto::SceneCamera>* _internal_mutable_scene_cameras();
  public:
  const ::frame::proto::SceneCamera& scene_cameras(int index) const;
  ::frame::proto::SceneCamera* add_scene_cameras();
  const ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneCamera >&
      scene_cameras() const;
  // repeated .frame.proto.SceneLight scene_lights = 6;
  int scene_lights_size() const;
  private:
  int _internal_scene_lights_size() const;

  public:
  void clear_scene_lights() ;
  ::frame::proto::SceneLight* mutable_scene_lights(int index);
  ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneLight >*
      mutable_scene_lights();
  private:
  const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneLight>& _internal_scene_lights() const;
  ::google::protobuf::RepeatedPtrField<::frame::proto::SceneLight>* _internal_mutable_scene_lights();
  public:
  const ::frame::proto::SceneLight& scene_lights(int index) const;
  ::frame::proto::SceneLight* add_scene_lights();
  const ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneLight >&
      scene_lights() const;
  // string default_root_name = 1;
  void clear_default_root_name() ;
  const std::string& default_root_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_root_name(Arg_&& arg, Args_... args);
  std::string* mutable_default_root_name();
  PROTOBUF_NODISCARD std::string* release_default_root_name();
  void set_allocated_default_root_name(std::string* value);

  private:
  const std::string& _internal_default_root_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_root_name(
      const std::string& value);
  std::string* _internal_mutable_default_root_name();

  public:
  // string default_camera_name = 2;
  void clear_default_camera_name() ;
  const std::string& default_camera_name() const;
  template <typename Arg_ = const std::string&, typename... Args_>
  void set_default_camera_name(Arg_&& arg, Args_... args);
  std::string* mutable_default_camera_name();
  PROTOBUF_NODISCARD std::string* release_default_camera_name();
  void set_allocated_default_camera_name(std::string* value);

  private:
  const std::string& _internal_default_camera_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_default_camera_name(
      const std::string& value);
  std::string* _internal_mutable_default_camera_name();

  public:
  // @@protoc_insertion_point(class_scope:frame.proto.SceneTree)
 private:
  class _Internal;

  friend class ::google::protobuf::internal::TcParser;
  static const ::google::protobuf::internal::TcParseTable<
      3, 6, 4,
      66, 2>
      _table_;
  friend class ::google::protobuf::MessageLite;
  friend class ::google::protobuf::Arena;
  template <typename T>
  friend class ::google::protobuf::Arena::InternalHelper;
  using InternalArenaConstructable_ = void;
  using DestructorSkippable_ = void;
  struct Impl_ {

        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena);
        inline explicit Impl_(::google::protobuf::internal::InternalVisibility visibility,
                              ::google::protobuf::Arena* arena, const Impl_& from);
    ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneMatrix > scene_matrices_;
    ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneStaticMesh > scene_static_meshes_;
    ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneCamera > scene_cameras_;
    ::google::protobuf::RepeatedPtrField< ::frame::proto::SceneLight > scene_lights_;
    ::google::protobuf::internal::ArenaStringPtr default_root_name_;
    ::google::protobuf::internal::ArenaStringPtr default_camera_name_;
    mutable ::google::protobuf::internal::CachedSize _cached_size_;
    PROTOBUF_TSAN_DECLARE_MEMBER
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_scene_2eproto;
};

// ===================================================================




// ===================================================================


#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SceneMatrix

// string name = 1;
inline void SceneMatrix::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SceneMatrix::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneMatrix.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneMatrix::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneMatrix.name)
}
inline std::string* SceneMatrix::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneMatrix.name)
  return _s;
}
inline const std::string& SceneMatrix::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void SceneMatrix::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SceneMatrix::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SceneMatrix::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneMatrix.name)
  return _impl_.name_.Release();
}
inline void SceneMatrix::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneMatrix.name)
}

// string parent = 2;
inline void SceneMatrix::clear_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& SceneMatrix::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneMatrix.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneMatrix::set_parent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneMatrix.parent)
}
inline std::string* SceneMatrix::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneMatrix.parent)
  return _s;
}
inline const std::string& SceneMatrix::_internal_parent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_.Get();
}
inline void SceneMatrix::_internal_set_parent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* SceneMatrix::_internal_mutable_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* SceneMatrix::release_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneMatrix.parent)
  return _impl_.parent_.Release();
}
inline void SceneMatrix::set_allocated_parent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_.IsDefault()) {
          _impl_.parent_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneMatrix.parent)
}

// .frame.proto.UniformMatrix4 matrix = 3;
inline bool SceneMatrix::has_matrix() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.matrix_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformMatrix4& SceneMatrix::_internal_matrix() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::frame::proto::UniformMatrix4* p = _impl_.matrix_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformMatrix4&>(::frame::proto::_UniformMatrix4_default_instance_);
}
inline const ::frame::proto::UniformMatrix4& SceneMatrix::matrix() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneMatrix.matrix)
  return _internal_matrix();
}
inline void SceneMatrix::unsafe_arena_set_allocated_matrix(::frame::proto::UniformMatrix4* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.matrix_);
  }
  _impl_.matrix_ = reinterpret_cast<::frame::proto::UniformMatrix4*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneMatrix.matrix)
}
inline ::frame::proto::UniformMatrix4* SceneMatrix::release_matrix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::frame::proto::UniformMatrix4* released = _impl_.matrix_;
  _impl_.matrix_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::frame::proto::UniformMatrix4* SceneMatrix::unsafe_arena_release_matrix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneMatrix.matrix)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::frame::proto::UniformMatrix4* temp = _impl_.matrix_;
  _impl_.matrix_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformMatrix4* SceneMatrix::_internal_mutable_matrix() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.matrix_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformMatrix4>(GetArena());
    _impl_.matrix_ = reinterpret_cast<::frame::proto::UniformMatrix4*>(p);
  }
  return _impl_.matrix_;
}
inline ::frame::proto::UniformMatrix4* SceneMatrix::mutable_matrix() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::UniformMatrix4* _msg = _internal_mutable_matrix();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneMatrix.matrix)
  return _msg;
}
inline void SceneMatrix::set_allocated_matrix(::frame::proto::UniformMatrix4* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.matrix_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.matrix_ = reinterpret_cast<::frame::proto::UniformMatrix4*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneMatrix.matrix)
}

// .frame.proto.UniformQuaternion quaternion = 4;
inline bool SceneMatrix::has_quaternion() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.quaternion_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformQuaternion& SceneMatrix::_internal_quaternion() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::frame::proto::UniformQuaternion* p = _impl_.quaternion_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformQuaternion&>(::frame::proto::_UniformQuaternion_default_instance_);
}
inline const ::frame::proto::UniformQuaternion& SceneMatrix::quaternion() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneMatrix.quaternion)
  return _internal_quaternion();
}
inline void SceneMatrix::unsafe_arena_set_allocated_quaternion(::frame::proto::UniformQuaternion* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quaternion_);
  }
  _impl_.quaternion_ = reinterpret_cast<::frame::proto::UniformQuaternion*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneMatrix.quaternion)
}
inline ::frame::proto::UniformQuaternion* SceneMatrix::release_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::frame::proto::UniformQuaternion* released = _impl_.quaternion_;
  _impl_.quaternion_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::frame::proto::UniformQuaternion* SceneMatrix::unsafe_arena_release_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneMatrix.quaternion)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::frame::proto::UniformQuaternion* temp = _impl_.quaternion_;
  _impl_.quaternion_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformQuaternion* SceneMatrix::_internal_mutable_quaternion() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.quaternion_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformQuaternion>(GetArena());
    _impl_.quaternion_ = reinterpret_cast<::frame::proto::UniformQuaternion*>(p);
  }
  return _impl_.quaternion_;
}
inline ::frame::proto::UniformQuaternion* SceneMatrix::mutable_quaternion() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::UniformQuaternion* _msg = _internal_mutable_quaternion();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneMatrix.quaternion)
  return _msg;
}
inline void SceneMatrix::set_allocated_quaternion(::frame::proto::UniformQuaternion* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.quaternion_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.quaternion_ = reinterpret_cast<::frame::proto::UniformQuaternion*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneMatrix.quaternion)
}

// -------------------------------------------------------------------

// SceneStaticMesh

// string name = 1;
inline void SceneStaticMesh::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SceneStaticMesh::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneStaticMesh::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.name)
}
inline std::string* SceneStaticMesh::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.name)
  return _s;
}
inline const std::string& SceneStaticMesh::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void SceneStaticMesh::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SceneStaticMesh::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SceneStaticMesh::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.name)
  return _impl_.name_.Release();
}
inline void SceneStaticMesh::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneStaticMesh.name)
}

// string parent = 2;
inline void SceneStaticMesh::clear_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& SceneStaticMesh::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneStaticMesh::set_parent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.parent)
}
inline std::string* SceneStaticMesh::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.parent)
  return _s;
}
inline const std::string& SceneStaticMesh::_internal_parent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_.Get();
}
inline void SceneStaticMesh::_internal_set_parent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* SceneStaticMesh::_internal_mutable_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* SceneStaticMesh::release_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.parent)
  return _impl_.parent_.Release();
}
inline void SceneStaticMesh::set_allocated_parent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_.IsDefault()) {
          _impl_.parent_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneStaticMesh.parent)
}

// .frame.proto.SceneStaticMesh.RenderPrimitiveEnum render_primitive_enum = 8;
inline void SceneStaticMesh::clear_render_primitive_enum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.render_primitive_enum_ = 0;
}
inline ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum SceneStaticMesh::render_primitive_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.render_primitive_enum)
  return _internal_render_primitive_enum();
}
inline void SceneStaticMesh::set_render_primitive_enum(::frame::proto::SceneStaticMesh_RenderPrimitiveEnum value) {
  _internal_set_render_primitive_enum(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.render_primitive_enum)
}
inline ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum SceneStaticMesh::_internal_render_primitive_enum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::frame::proto::SceneStaticMesh_RenderPrimitiveEnum>(_impl_.render_primitive_enum_);
}
inline void SceneStaticMesh::_internal_set_render_primitive_enum(::frame::proto::SceneStaticMesh_RenderPrimitiveEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.render_primitive_enum_ = value;
}

// .frame.proto.CleanBuffer clean_buffer = 7;
inline bool SceneStaticMesh::has_clean_buffer() const {
  return mesh_oneof_case() == kCleanBuffer;
}
inline bool SceneStaticMesh::_internal_has_clean_buffer() const {
  return mesh_oneof_case() == kCleanBuffer;
}
inline void SceneStaticMesh::set_has_clean_buffer() {
  _impl_._oneof_case_[0] = kCleanBuffer;
}
inline ::frame::proto::CleanBuffer* SceneStaticMesh::release_clean_buffer() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.clean_buffer)
  if (mesh_oneof_case() == kCleanBuffer) {
    clear_has_mesh_oneof();
    auto* temp = _impl_.mesh_oneof_.clean_buffer_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mesh_oneof_.clean_buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::frame::proto::CleanBuffer& SceneStaticMesh::_internal_clean_buffer() const {
  return mesh_oneof_case() == kCleanBuffer ? *_impl_.mesh_oneof_.clean_buffer_ : reinterpret_cast<::frame::proto::CleanBuffer&>(::frame::proto::_CleanBuffer_default_instance_);
}
inline const ::frame::proto::CleanBuffer& SceneStaticMesh::clean_buffer() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.clean_buffer)
  return _internal_clean_buffer();
}
inline ::frame::proto::CleanBuffer* SceneStaticMesh::unsafe_arena_release_clean_buffer() {
  // @@protoc_insertion_point(field_unsafe_arena_release:frame.proto.SceneStaticMesh.clean_buffer)
  if (mesh_oneof_case() == kCleanBuffer) {
    clear_has_mesh_oneof();
    auto* temp = _impl_.mesh_oneof_.clean_buffer_;
    _impl_.mesh_oneof_.clean_buffer_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SceneStaticMesh::unsafe_arena_set_allocated_clean_buffer(::frame::proto::CleanBuffer* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mesh_oneof();
  if (value) {
    set_has_clean_buffer();
    _impl_.mesh_oneof_.clean_buffer_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneStaticMesh.clean_buffer)
}
inline ::frame::proto::CleanBuffer* SceneStaticMesh::_internal_mutable_clean_buffer() {
  if (mesh_oneof_case() != kCleanBuffer) {
    clear_mesh_oneof();
    set_has_clean_buffer();
    _impl_.mesh_oneof_.clean_buffer_ = CreateMaybeMessage<::frame::proto::CleanBuffer>(GetArena());
  }
  return _impl_.mesh_oneof_.clean_buffer_;
}
inline ::frame::proto::CleanBuffer* SceneStaticMesh::mutable_clean_buffer() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::CleanBuffer* _msg = _internal_mutable_clean_buffer();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.clean_buffer)
  return _msg;
}

// .frame.proto.SceneStaticMesh.MeshEnum mesh_enum = 6;
inline bool SceneStaticMesh::has_mesh_enum() const {
  return mesh_oneof_case() == kMeshEnum;
}
inline void SceneStaticMesh::set_has_mesh_enum() {
  _impl_._oneof_case_[0] = kMeshEnum;
}
inline void SceneStaticMesh::clear_mesh_enum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mesh_oneof_case() == kMeshEnum) {
    _impl_.mesh_oneof_.mesh_enum_ = 0;
    clear_has_mesh_oneof();
  }
}
inline ::frame::proto::SceneStaticMesh_MeshEnum SceneStaticMesh::mesh_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.mesh_enum)
  return _internal_mesh_enum();
}
inline void SceneStaticMesh::set_mesh_enum(::frame::proto::SceneStaticMesh_MeshEnum value) {
  _internal_set_mesh_enum(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.mesh_enum)
}
inline ::frame::proto::SceneStaticMesh_MeshEnum SceneStaticMesh::_internal_mesh_enum() const {
  if (mesh_oneof_case() == kMeshEnum) {
    return static_cast<::frame::proto::SceneStaticMesh_MeshEnum>(_impl_.mesh_oneof_.mesh_enum_);
  }
  return static_cast<::frame::proto::SceneStaticMesh_MeshEnum>(0);
}
inline void SceneStaticMesh::_internal_set_mesh_enum(::frame::proto::SceneStaticMesh_MeshEnum value) {
  if (mesh_oneof_case() != kMeshEnum) {
    clear_mesh_oneof();
    set_has_mesh_enum();
  }
  _impl_.mesh_oneof_.mesh_enum_ = value;
}

// string file_name = 3;
inline bool SceneStaticMesh::has_file_name() const {
  return mesh_oneof_case() == kFileName;
}
inline void SceneStaticMesh::set_has_file_name() {
  _impl_._oneof_case_[0] = kFileName;
}
inline void SceneStaticMesh::clear_file_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mesh_oneof_case() == kFileName) {
    _impl_.mesh_oneof_.file_name_.Destroy();
    clear_has_mesh_oneof();
  }
}
inline const std::string& SceneStaticMesh::file_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.file_name)
  return _internal_file_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneStaticMesh::set_file_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mesh_oneof_case() != kFileName) {
    clear_mesh_oneof();

    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitDefault();
  }
  _impl_.mesh_oneof_.file_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.file_name)
}
inline std::string* SceneStaticMesh::mutable_file_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_file_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.file_name)
  return _s;
}
inline const std::string& SceneStaticMesh::_internal_file_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  if (mesh_oneof_case() != kFileName) {
    return ::google::protobuf::internal::GetEmptyStringAlreadyInited();
  }
  return _impl_.mesh_oneof_.file_name_.Get();
}
inline void SceneStaticMesh::_internal_set_file_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mesh_oneof_case() != kFileName) {
    clear_mesh_oneof();

    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitDefault();
  }
  _impl_.mesh_oneof_.file_name_.Set(value, GetArena());
}
inline std::string* SceneStaticMesh::_internal_mutable_file_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (mesh_oneof_case() != kFileName) {
    clear_mesh_oneof();

    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitDefault();
  }
  return _impl_.mesh_oneof_.file_name_.Mutable( GetArena());
}
inline std::string* SceneStaticMesh::release_file_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.file_name)
  if (mesh_oneof_case() != kFileName) {
    return nullptr;
  }
  clear_has_mesh_oneof();
  return _impl_.mesh_oneof_.file_name_.Release();
}
inline void SceneStaticMesh::set_allocated_file_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (has_mesh_oneof()) {
    clear_mesh_oneof();
  }
  if (value != nullptr) {
    set_has_file_name();
    _impl_.mesh_oneof_.file_name_.InitAllocated(value, GetArena());
  }
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneStaticMesh.file_name)
}

// .frame.proto.MultiPlugin multi_plugin = 10;
inline bool SceneStaticMesh::has_multi_plugin() const {
  return mesh_oneof_case() == kMultiPlugin;
}
inline bool SceneStaticMesh::_internal_has_multi_plugin() const {
  return mesh_oneof_case() == kMultiPlugin;
}
inline void SceneStaticMesh::set_has_multi_plugin() {
  _impl_._oneof_case_[0] = kMultiPlugin;
}
inline ::frame::proto::MultiPlugin* SceneStaticMesh::release_multi_plugin() {
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.multi_plugin)
  if (mesh_oneof_case() == kMultiPlugin) {
    clear_has_mesh_oneof();
    auto* temp = _impl_.mesh_oneof_.multi_plugin_;
    if (GetArena() != nullptr) {
      temp = ::google::protobuf::internal::DuplicateIfNonNull(temp);
    }
    _impl_.mesh_oneof_.multi_plugin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::frame::proto::MultiPlugin& SceneStaticMesh::_internal_multi_plugin() const {
  return mesh_oneof_case() == kMultiPlugin ? *_impl_.mesh_oneof_.multi_plugin_ : reinterpret_cast<::frame::proto::MultiPlugin&>(::frame::proto::_MultiPlugin_default_instance_);
}
inline const ::frame::proto::MultiPlugin& SceneStaticMesh::multi_plugin() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.multi_plugin)
  return _internal_multi_plugin();
}
inline ::frame::proto::MultiPlugin* SceneStaticMesh::unsafe_arena_release_multi_plugin() {
  // @@protoc_insertion_point(field_unsafe_arena_release:frame.proto.SceneStaticMesh.multi_plugin)
  if (mesh_oneof_case() == kMultiPlugin) {
    clear_has_mesh_oneof();
    auto* temp = _impl_.mesh_oneof_.multi_plugin_;
    _impl_.mesh_oneof_.multi_plugin_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void SceneStaticMesh::unsafe_arena_set_allocated_multi_plugin(::frame::proto::MultiPlugin* value) {
  // We rely on the oneof clear method to free the earlier contents
  // of this oneof. We can directly use the pointer we're given to
  // set the new value.
  clear_mesh_oneof();
  if (value) {
    set_has_multi_plugin();
    _impl_.mesh_oneof_.multi_plugin_ = value;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneStaticMesh.multi_plugin)
}
inline ::frame::proto::MultiPlugin* SceneStaticMesh::_internal_mutable_multi_plugin() {
  if (mesh_oneof_case() != kMultiPlugin) {
    clear_mesh_oneof();
    set_has_multi_plugin();
    _impl_.mesh_oneof_.multi_plugin_ = CreateMaybeMessage<::frame::proto::MultiPlugin>(GetArena());
  }
  return _impl_.mesh_oneof_.multi_plugin_;
}
inline ::frame::proto::MultiPlugin* SceneStaticMesh::mutable_multi_plugin() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::MultiPlugin* _msg = _internal_mutable_multi_plugin();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.multi_plugin)
  return _msg;
}

// string material_name = 5;
inline void SceneStaticMesh::clear_material_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.material_name_.ClearToEmpty();
}
inline const std::string& SceneStaticMesh::material_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.material_name)
  return _internal_material_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneStaticMesh::set_material_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.material_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.material_name)
}
inline std::string* SceneStaticMesh::mutable_material_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_material_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneStaticMesh.material_name)
  return _s;
}
inline const std::string& SceneStaticMesh::_internal_material_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.material_name_.Get();
}
inline void SceneStaticMesh::_internal_set_material_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.material_name_.Set(value, GetArena());
}
inline std::string* SceneStaticMesh::_internal_mutable_material_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.material_name_.Mutable( GetArena());
}
inline std::string* SceneStaticMesh::release_material_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneStaticMesh.material_name)
  return _impl_.material_name_.Release();
}
inline void SceneStaticMesh::set_allocated_material_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.material_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.material_name_.IsDefault()) {
          _impl_.material_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneStaticMesh.material_name)
}

// .frame.proto.SceneStaticMesh.RenderTimeEnum render_time_enum = 11;
inline void SceneStaticMesh::clear_render_time_enum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.render_time_enum_ = 0;
}
inline ::frame::proto::SceneStaticMesh_RenderTimeEnum SceneStaticMesh::render_time_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.render_time_enum)
  return _internal_render_time_enum();
}
inline void SceneStaticMesh::set_render_time_enum(::frame::proto::SceneStaticMesh_RenderTimeEnum value) {
  _internal_set_render_time_enum(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.render_time_enum)
}
inline ::frame::proto::SceneStaticMesh_RenderTimeEnum SceneStaticMesh::_internal_render_time_enum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::frame::proto::SceneStaticMesh_RenderTimeEnum>(_impl_.render_time_enum_);
}
inline void SceneStaticMesh::_internal_set_render_time_enum(::frame::proto::SceneStaticMesh_RenderTimeEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.render_time_enum_ = value;
}

// .frame.proto.SceneStaticMesh.ShadowEffectEnum shadow_effect_enum = 12;
inline void SceneStaticMesh::clear_shadow_effect_enum() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shadow_effect_enum_ = 0;
}
inline ::frame::proto::SceneStaticMesh_ShadowEffectEnum SceneStaticMesh::shadow_effect_enum() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneStaticMesh.shadow_effect_enum)
  return _internal_shadow_effect_enum();
}
inline void SceneStaticMesh::set_shadow_effect_enum(::frame::proto::SceneStaticMesh_ShadowEffectEnum value) {
  _internal_set_shadow_effect_enum(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneStaticMesh.shadow_effect_enum)
}
inline ::frame::proto::SceneStaticMesh_ShadowEffectEnum SceneStaticMesh::_internal_shadow_effect_enum() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::frame::proto::SceneStaticMesh_ShadowEffectEnum>(_impl_.shadow_effect_enum_);
}
inline void SceneStaticMesh::_internal_set_shadow_effect_enum(::frame::proto::SceneStaticMesh_ShadowEffectEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shadow_effect_enum_ = value;
}

inline bool SceneStaticMesh::has_mesh_oneof() const {
  return mesh_oneof_case() != MESH_ONEOF_NOT_SET;
}
inline void SceneStaticMesh::clear_has_mesh_oneof() {
  _impl_._oneof_case_[0] = MESH_ONEOF_NOT_SET;
}
inline SceneStaticMesh::MeshOneofCase SceneStaticMesh::mesh_oneof_case() const {
  return SceneStaticMesh::MeshOneofCase(_impl_._oneof_case_[0]);
}
// -------------------------------------------------------------------

// SceneCamera

// string name = 1;
inline void SceneCamera::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SceneCamera::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneCamera::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.name)
}
inline std::string* SceneCamera::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneCamera.name)
  return _s;
}
inline const std::string& SceneCamera::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void SceneCamera::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SceneCamera::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SceneCamera::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneCamera.name)
  return _impl_.name_.Release();
}
inline void SceneCamera::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneCamera.name)
}

// string parent = 2;
inline void SceneCamera::clear_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& SceneCamera::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneCamera::set_parent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.parent)
}
inline std::string* SceneCamera::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneCamera.parent)
  return _s;
}
inline const std::string& SceneCamera::_internal_parent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_.Get();
}
inline void SceneCamera::_internal_set_parent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* SceneCamera::_internal_mutable_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* SceneCamera::release_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneCamera.parent)
  return _impl_.parent_.Release();
}
inline void SceneCamera::set_allocated_parent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_.IsDefault()) {
          _impl_.parent_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneCamera.parent)
}

// .frame.proto.UniformVector3 position = 3;
inline bool SceneCamera::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& SceneCamera::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::frame::proto::UniformVector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneCamera::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.position)
  return _internal_position();
}
inline void SceneCamera::unsafe_arena_set_allocated_position(::frame::proto::UniformVector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneCamera.position)
}
inline ::frame::proto::UniformVector3* SceneCamera::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::frame::proto::UniformVector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::frame::proto::UniformVector3* SceneCamera::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneCamera.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::frame::proto::UniformVector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneCamera::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.position_;
}
inline ::frame::proto::UniformVector3* SceneCamera::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneCamera.position)
  return _msg;
}
inline void SceneCamera::set_allocated_position(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneCamera.position)
}

// .frame.proto.UniformVector3 target = 4;
inline bool SceneCamera::has_target() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.target_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& SceneCamera::_internal_target() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::frame::proto::UniformVector3* p = _impl_.target_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneCamera::target() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.target)
  return _internal_target();
}
inline void SceneCamera::unsafe_arena_set_allocated_target(::frame::proto::UniformVector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }
  _impl_.target_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneCamera.target)
}
inline ::frame::proto::UniformVector3* SceneCamera::release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::frame::proto::UniformVector3* released = _impl_.target_;
  _impl_.target_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::frame::proto::UniformVector3* SceneCamera::unsafe_arena_release_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneCamera.target)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::frame::proto::UniformVector3* temp = _impl_.target_;
  _impl_.target_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneCamera::_internal_mutable_target() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.target_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArena());
    _impl_.target_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.target_;
}
inline ::frame::proto::UniformVector3* SceneCamera::mutable_target() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_target();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneCamera.target)
  return _msg;
}
inline void SceneCamera::set_allocated_target(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.target_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.target_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneCamera.target)
}

// .frame.proto.UniformVector3 up = 5;
inline bool SceneCamera::has_up() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.up_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& SceneCamera::_internal_up() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::frame::proto::UniformVector3* p = _impl_.up_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneCamera::up() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.up)
  return _internal_up();
}
inline void SceneCamera::unsafe_arena_set_allocated_up(::frame::proto::UniformVector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.up_);
  }
  _impl_.up_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneCamera.up)
}
inline ::frame::proto::UniformVector3* SceneCamera::release_up() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::frame::proto::UniformVector3* released = _impl_.up_;
  _impl_.up_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::frame::proto::UniformVector3* SceneCamera::unsafe_arena_release_up() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneCamera.up)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::frame::proto::UniformVector3* temp = _impl_.up_;
  _impl_.up_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneCamera::_internal_mutable_up() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.up_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArena());
    _impl_.up_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.up_;
}
inline ::frame::proto::UniformVector3* SceneCamera::mutable_up() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_up();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneCamera.up)
  return _msg;
}
inline void SceneCamera::set_allocated_up(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.up_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.up_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneCamera.up)
}

// float fov_degrees = 6;
inline void SceneCamera::clear_fov_degrees() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.fov_degrees_ = 0;
}
inline float SceneCamera::fov_degrees() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.fov_degrees)
  return _internal_fov_degrees();
}
inline void SceneCamera::set_fov_degrees(float value) {
  _internal_set_fov_degrees(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.fov_degrees)
}
inline float SceneCamera::_internal_fov_degrees() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.fov_degrees_;
}
inline void SceneCamera::_internal_set_fov_degrees(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.fov_degrees_ = value;
}

// float aspect_ratio = 7;
inline void SceneCamera::clear_aspect_ratio() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.aspect_ratio_ = 0;
}
inline float SceneCamera::aspect_ratio() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.aspect_ratio)
  return _internal_aspect_ratio();
}
inline void SceneCamera::set_aspect_ratio(float value) {
  _internal_set_aspect_ratio(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.aspect_ratio)
}
inline float SceneCamera::_internal_aspect_ratio() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.aspect_ratio_;
}
inline void SceneCamera::_internal_set_aspect_ratio(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.aspect_ratio_ = value;
}

// float near_clip = 8;
inline void SceneCamera::clear_near_clip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.near_clip_ = 0;
}
inline float SceneCamera::near_clip() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.near_clip)
  return _internal_near_clip();
}
inline void SceneCamera::set_near_clip(float value) {
  _internal_set_near_clip(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.near_clip)
}
inline float SceneCamera::_internal_near_clip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.near_clip_;
}
inline void SceneCamera::_internal_set_near_clip(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.near_clip_ = value;
}

// float far_clip = 9;
inline void SceneCamera::clear_far_clip() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.far_clip_ = 0;
}
inline float SceneCamera::far_clip() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneCamera.far_clip)
  return _internal_far_clip();
}
inline void SceneCamera::set_far_clip(float value) {
  _internal_set_far_clip(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneCamera.far_clip)
}
inline float SceneCamera::_internal_far_clip() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.far_clip_;
}
inline void SceneCamera::_internal_set_far_clip(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.far_clip_ = value;
}

// -------------------------------------------------------------------

// SceneLight

// string name = 1;
inline void SceneLight::clear_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.ClearToEmpty();
}
inline const std::string& SceneLight::name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.name)
  return _internal_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneLight::set_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.name)
}
inline std::string* SceneLight::mutable_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.name)
  return _s;
}
inline const std::string& SceneLight::_internal_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.name_.Get();
}
inline void SceneLight::_internal_set_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.name_.Set(value, GetArena());
}
inline std::string* SceneLight::_internal_mutable_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.name_.Mutable( GetArena());
}
inline std::string* SceneLight::release_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.name)
  return _impl_.name_.Release();
}
inline void SceneLight::set_allocated_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.name_.IsDefault()) {
          _impl_.name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.name)
}

// string parent = 2;
inline void SceneLight::clear_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.ClearToEmpty();
}
inline const std::string& SceneLight::parent() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.parent)
  return _internal_parent();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneLight::set_parent(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.parent)
}
inline std::string* SceneLight::mutable_parent() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_parent();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.parent)
  return _s;
}
inline const std::string& SceneLight::_internal_parent() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.parent_.Get();
}
inline void SceneLight::_internal_set_parent(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.parent_.Set(value, GetArena());
}
inline std::string* SceneLight::_internal_mutable_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.parent_.Mutable( GetArena());
}
inline std::string* SceneLight::release_parent() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.parent)
  return _impl_.parent_.Release();
}
inline void SceneLight::set_allocated_parent(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.parent_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.parent_.IsDefault()) {
          _impl_.parent_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.parent)
}

// .frame.proto.SceneLight.LightTypeEnum light_type = 3;
inline void SceneLight::clear_light_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.light_type_ = 0;
}
inline ::frame::proto::SceneLight_LightTypeEnum SceneLight::light_type() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.light_type)
  return _internal_light_type();
}
inline void SceneLight::set_light_type(::frame::proto::SceneLight_LightTypeEnum value) {
  _internal_set_light_type(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.light_type)
}
inline ::frame::proto::SceneLight_LightTypeEnum SceneLight::_internal_light_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::frame::proto::SceneLight_LightTypeEnum>(_impl_.light_type_);
}
inline void SceneLight::_internal_set_light_type(::frame::proto::SceneLight_LightTypeEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.light_type_ = value;
}

// .frame.proto.UniformVector3 position = 4;
inline bool SceneLight::has_position() const {
  bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.position_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& SceneLight::_internal_position() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::frame::proto::UniformVector3* p = _impl_.position_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneLight::position() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.position)
  return _internal_position();
}
inline void SceneLight::unsafe_arena_set_allocated_position(::frame::proto::UniformVector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }
  _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneLight.position)
}
inline ::frame::proto::UniformVector3* SceneLight::release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::frame::proto::UniformVector3* released = _impl_.position_;
  _impl_.position_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::frame::proto::UniformVector3* SceneLight::unsafe_arena_release_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.position)

  _impl_._has_bits_[0] &= ~0x00000001u;
  ::frame::proto::UniformVector3* temp = _impl_.position_;
  _impl_.position_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneLight::_internal_mutable_position() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000001u;
  if (_impl_.position_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArena());
    _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.position_;
}
inline ::frame::proto::UniformVector3* SceneLight::mutable_position() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_position();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.position)
  return _msg;
}
inline void SceneLight::set_allocated_position(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.position_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000001u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000001u;
  }

  _impl_.position_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.position)
}

// .frame.proto.UniformVector3 direction = 5;
inline bool SceneLight::has_direction() const {
  bool value = (_impl_._has_bits_[0] & 0x00000002u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.direction_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& SceneLight::_internal_direction() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::frame::proto::UniformVector3* p = _impl_.direction_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneLight::direction() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.direction)
  return _internal_direction();
}
inline void SceneLight::unsafe_arena_set_allocated_direction(::frame::proto::UniformVector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.direction_);
  }
  _impl_.direction_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneLight.direction)
}
inline ::frame::proto::UniformVector3* SceneLight::release_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::frame::proto::UniformVector3* released = _impl_.direction_;
  _impl_.direction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::frame::proto::UniformVector3* SceneLight::unsafe_arena_release_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.direction)

  _impl_._has_bits_[0] &= ~0x00000002u;
  ::frame::proto::UniformVector3* temp = _impl_.direction_;
  _impl_.direction_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneLight::_internal_mutable_direction() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000002u;
  if (_impl_.direction_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArena());
    _impl_.direction_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.direction_;
}
inline ::frame::proto::UniformVector3* SceneLight::mutable_direction() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_direction();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.direction)
  return _msg;
}
inline void SceneLight::set_allocated_direction(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.direction_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000002u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000002u;
  }

  _impl_.direction_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.direction)
}

// float dot_inner_limit = 6;
inline void SceneLight::clear_dot_inner_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dot_inner_limit_ = 0;
}
inline float SceneLight::dot_inner_limit() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.dot_inner_limit)
  return _internal_dot_inner_limit();
}
inline void SceneLight::set_dot_inner_limit(float value) {
  _internal_set_dot_inner_limit(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.dot_inner_limit)
}
inline float SceneLight::_internal_dot_inner_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dot_inner_limit_;
}
inline void SceneLight::_internal_set_dot_inner_limit(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dot_inner_limit_ = value;
}

// float dot_outer_limit = 7;
inline void SceneLight::clear_dot_outer_limit() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.dot_outer_limit_ = 0;
}
inline float SceneLight::dot_outer_limit() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.dot_outer_limit)
  return _internal_dot_outer_limit();
}
inline void SceneLight::set_dot_outer_limit(float value) {
  _internal_set_dot_outer_limit(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.dot_outer_limit)
}
inline float SceneLight::_internal_dot_outer_limit() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.dot_outer_limit_;
}
inline void SceneLight::_internal_set_dot_outer_limit(float value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.dot_outer_limit_ = value;
}

// .frame.proto.UniformVector3 color = 8;
inline bool SceneLight::has_color() const {
  bool value = (_impl_._has_bits_[0] & 0x00000004u) != 0;
  PROTOBUF_ASSUME(!value || _impl_.color_ != nullptr);
  return value;
}
inline const ::frame::proto::UniformVector3& SceneLight::_internal_color() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  const ::frame::proto::UniformVector3* p = _impl_.color_;
  return p != nullptr ? *p : reinterpret_cast<const ::frame::proto::UniformVector3&>(::frame::proto::_UniformVector3_default_instance_);
}
inline const ::frame::proto::UniformVector3& SceneLight::color() const ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.color)
  return _internal_color();
}
inline void SceneLight::unsafe_arena_set_allocated_color(::frame::proto::UniformVector3* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (GetArena() == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }
  _impl_.color_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  if (value != nullptr) {
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:frame.proto.SceneLight.color)
}
inline ::frame::proto::UniformVector3* SceneLight::release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::frame::proto::UniformVector3* released = _impl_.color_;
  _impl_.color_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
  released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  if (GetArena() == nullptr) {
    delete old;
  }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArena() != nullptr) {
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return released;
}
inline ::frame::proto::UniformVector3* SceneLight::unsafe_arena_release_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.color)

  _impl_._has_bits_[0] &= ~0x00000004u;
  ::frame::proto::UniformVector3* temp = _impl_.color_;
  _impl_.color_ = nullptr;
  return temp;
}
inline ::frame::proto::UniformVector3* SceneLight::_internal_mutable_color() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_._has_bits_[0] |= 0x00000004u;
  if (_impl_.color_ == nullptr) {
    auto* p = CreateMaybeMessage<::frame::proto::UniformVector3>(GetArena());
    _impl_.color_ = reinterpret_cast<::frame::proto::UniformVector3*>(p);
  }
  return _impl_.color_;
}
inline ::frame::proto::UniformVector3* SceneLight::mutable_color() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  ::frame::proto::UniformVector3* _msg = _internal_mutable_color();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.color)
  return _msg;
}
inline void SceneLight::set_allocated_color(::frame::proto::UniformVector3* value) {
  ::google::protobuf::Arena* message_arena = GetArena();
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  if (message_arena == nullptr) {
    delete reinterpret_cast<::google::protobuf::MessageLite*>(_impl_.color_);
  }

  if (value != nullptr) {
    ::google::protobuf::Arena* submessage_arena = reinterpret_cast<::google::protobuf::MessageLite*>(value)->GetArena();
    if (message_arena != submessage_arena) {
      value = ::google::protobuf::internal::GetOwnedMessage(message_arena, value, submessage_arena);
    }
    _impl_._has_bits_[0] |= 0x00000004u;
  } else {
    _impl_._has_bits_[0] &= ~0x00000004u;
  }

  _impl_.color_ = reinterpret_cast<::frame::proto::UniformVector3*>(value);
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.color)
}

// .frame.proto.SceneLight.ShadowTypeEnum shadow_type = 9;
inline void SceneLight::clear_shadow_type() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shadow_type_ = 0;
}
inline ::frame::proto::SceneLight_ShadowTypeEnum SceneLight::shadow_type() const {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.shadow_type)
  return _internal_shadow_type();
}
inline void SceneLight::set_shadow_type(::frame::proto::SceneLight_ShadowTypeEnum value) {
  _internal_set_shadow_type(value);
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.shadow_type)
}
inline ::frame::proto::SceneLight_ShadowTypeEnum SceneLight::_internal_shadow_type() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return static_cast<::frame::proto::SceneLight_ShadowTypeEnum>(_impl_.shadow_type_);
}
inline void SceneLight::_internal_set_shadow_type(::frame::proto::SceneLight_ShadowTypeEnum value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shadow_type_ = value;
}

// string shadow_texture = 10;
inline void SceneLight::clear_shadow_texture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shadow_texture_.ClearToEmpty();
}
inline const std::string& SceneLight::shadow_texture() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneLight.shadow_texture)
  return _internal_shadow_texture();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneLight::set_shadow_texture(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shadow_texture_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneLight.shadow_texture)
}
inline std::string* SceneLight::mutable_shadow_texture() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_shadow_texture();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneLight.shadow_texture)
  return _s;
}
inline const std::string& SceneLight::_internal_shadow_texture() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.shadow_texture_.Get();
}
inline void SceneLight::_internal_set_shadow_texture(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.shadow_texture_.Set(value, GetArena());
}
inline std::string* SceneLight::_internal_mutable_shadow_texture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.shadow_texture_.Mutable( GetArena());
}
inline std::string* SceneLight::release_shadow_texture() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneLight.shadow_texture)
  return _impl_.shadow_texture_.Release();
}
inline void SceneLight::set_allocated_shadow_texture(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.shadow_texture_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.shadow_texture_.IsDefault()) {
          _impl_.shadow_texture_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneLight.shadow_texture)
}

// -------------------------------------------------------------------

// SceneTree

// string default_root_name = 1;
inline void SceneTree::clear_default_root_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.default_root_name_.ClearToEmpty();
}
inline const std::string& SceneTree::default_root_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.default_root_name)
  return _internal_default_root_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneTree::set_default_root_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.default_root_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneTree.default_root_name)
}
inline std::string* SceneTree::mutable_default_root_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_default_root_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.default_root_name)
  return _s;
}
inline const std::string& SceneTree::_internal_default_root_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.default_root_name_.Get();
}
inline void SceneTree::_internal_set_default_root_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.default_root_name_.Set(value, GetArena());
}
inline std::string* SceneTree::_internal_mutable_default_root_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.default_root_name_.Mutable( GetArena());
}
inline std::string* SceneTree::release_default_root_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneTree.default_root_name)
  return _impl_.default_root_name_.Release();
}
inline void SceneTree::set_allocated_default_root_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.default_root_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_root_name_.IsDefault()) {
          _impl_.default_root_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneTree.default_root_name)
}

// string default_camera_name = 2;
inline void SceneTree::clear_default_camera_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.default_camera_name_.ClearToEmpty();
}
inline const std::string& SceneTree::default_camera_name() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.default_camera_name)
  return _internal_default_camera_name();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void SceneTree::set_default_camera_name(Arg_&& arg,
                                                     Args_... args) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.default_camera_name_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
  // @@protoc_insertion_point(field_set:frame.proto.SceneTree.default_camera_name)
}
inline std::string* SceneTree::mutable_default_camera_name() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  std::string* _s = _internal_mutable_default_camera_name();
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.default_camera_name)
  return _s;
}
inline const std::string& SceneTree::_internal_default_camera_name() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.default_camera_name_.Get();
}
inline void SceneTree::_internal_set_default_camera_name(const std::string& value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  _impl_.default_camera_name_.Set(value, GetArena());
}
inline std::string* SceneTree::_internal_mutable_default_camera_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ;
  return _impl_.default_camera_name_.Mutable( GetArena());
}
inline std::string* SceneTree::release_default_camera_name() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  // @@protoc_insertion_point(field_release:frame.proto.SceneTree.default_camera_name)
  return _impl_.default_camera_name_.Release();
}
inline void SceneTree::set_allocated_default_camera_name(std::string* value) {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.default_camera_name_.SetAllocated(value, GetArena());
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
        if (_impl_.default_camera_name_.IsDefault()) {
          _impl_.default_camera_name_.Set("", GetArena());
        }
  #endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:frame.proto.SceneTree.default_camera_name)
}

// repeated .frame.proto.SceneMatrix scene_matrices = 3;
inline int SceneTree::_internal_scene_matrices_size() const {
  return _internal_scene_matrices().size();
}
inline int SceneTree::scene_matrices_size() const {
  return _internal_scene_matrices_size();
}
inline void SceneTree::clear_scene_matrices() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scene_matrices_.Clear();
}
inline ::frame::proto::SceneMatrix* SceneTree::mutable_scene_matrices(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.scene_matrices)
  return _internal_mutable_scene_matrices()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::SceneMatrix>* SceneTree::mutable_scene_matrices()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.scene_matrices)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_scene_matrices();
}
inline const ::frame::proto::SceneMatrix& SceneTree::scene_matrices(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.scene_matrices)
  return _internal_scene_matrices().Get(index);
}
inline ::frame::proto::SceneMatrix* SceneTree::add_scene_matrices() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::frame::proto::SceneMatrix* _add = _internal_mutable_scene_matrices()->Add();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.scene_matrices)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneMatrix>& SceneTree::scene_matrices() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.scene_matrices)
  return _internal_scene_matrices();
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneMatrix>&
SceneTree::_internal_scene_matrices() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scene_matrices_;
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::SceneMatrix>*
SceneTree::_internal_mutable_scene_matrices() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.scene_matrices_;
}

// repeated .frame.proto.SceneStaticMesh scene_static_meshes = 4;
inline int SceneTree::_internal_scene_static_meshes_size() const {
  return _internal_scene_static_meshes().size();
}
inline int SceneTree::scene_static_meshes_size() const {
  return _internal_scene_static_meshes_size();
}
inline void SceneTree::clear_scene_static_meshes() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scene_static_meshes_.Clear();
}
inline ::frame::proto::SceneStaticMesh* SceneTree::mutable_scene_static_meshes(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.scene_static_meshes)
  return _internal_mutable_scene_static_meshes()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::SceneStaticMesh>* SceneTree::mutable_scene_static_meshes()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.scene_static_meshes)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_scene_static_meshes();
}
inline const ::frame::proto::SceneStaticMesh& SceneTree::scene_static_meshes(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.scene_static_meshes)
  return _internal_scene_static_meshes().Get(index);
}
inline ::frame::proto::SceneStaticMesh* SceneTree::add_scene_static_meshes() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::frame::proto::SceneStaticMesh* _add = _internal_mutable_scene_static_meshes()->Add();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.scene_static_meshes)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneStaticMesh>& SceneTree::scene_static_meshes() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.scene_static_meshes)
  return _internal_scene_static_meshes();
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneStaticMesh>&
SceneTree::_internal_scene_static_meshes() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scene_static_meshes_;
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::SceneStaticMesh>*
SceneTree::_internal_mutable_scene_static_meshes() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.scene_static_meshes_;
}

// repeated .frame.proto.SceneCamera scene_cameras = 5;
inline int SceneTree::_internal_scene_cameras_size() const {
  return _internal_scene_cameras().size();
}
inline int SceneTree::scene_cameras_size() const {
  return _internal_scene_cameras_size();
}
inline void SceneTree::clear_scene_cameras() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scene_cameras_.Clear();
}
inline ::frame::proto::SceneCamera* SceneTree::mutable_scene_cameras(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.scene_cameras)
  return _internal_mutable_scene_cameras()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::SceneCamera>* SceneTree::mutable_scene_cameras()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.scene_cameras)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_scene_cameras();
}
inline const ::frame::proto::SceneCamera& SceneTree::scene_cameras(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.scene_cameras)
  return _internal_scene_cameras().Get(index);
}
inline ::frame::proto::SceneCamera* SceneTree::add_scene_cameras() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::frame::proto::SceneCamera* _add = _internal_mutable_scene_cameras()->Add();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.scene_cameras)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneCamera>& SceneTree::scene_cameras() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.scene_cameras)
  return _internal_scene_cameras();
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneCamera>&
SceneTree::_internal_scene_cameras() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scene_cameras_;
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::SceneCamera>*
SceneTree::_internal_mutable_scene_cameras() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.scene_cameras_;
}

// repeated .frame.proto.SceneLight scene_lights = 6;
inline int SceneTree::_internal_scene_lights_size() const {
  return _internal_scene_lights().size();
}
inline int SceneTree::scene_lights_size() const {
  return _internal_scene_lights_size();
}
inline void SceneTree::clear_scene_lights() {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  _impl_.scene_lights_.Clear();
}
inline ::frame::proto::SceneLight* SceneTree::mutable_scene_lights(int index)
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable:frame.proto.SceneTree.scene_lights)
  return _internal_mutable_scene_lights()->Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::SceneLight>* SceneTree::mutable_scene_lights()
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_mutable_list:frame.proto.SceneTree.scene_lights)
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  return _internal_mutable_scene_lights();
}
inline const ::frame::proto::SceneLight& SceneTree::scene_lights(int index) const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_get:frame.proto.SceneTree.scene_lights)
  return _internal_scene_lights().Get(index);
}
inline ::frame::proto::SceneLight* SceneTree::add_scene_lights() ABSL_ATTRIBUTE_LIFETIME_BOUND {
  PROTOBUF_TSAN_WRITE(&_impl_._tsan_detect_race);
  ::frame::proto::SceneLight* _add = _internal_mutable_scene_lights()->Add();
  // @@protoc_insertion_point(field_add:frame.proto.SceneTree.scene_lights)
  return _add;
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneLight>& SceneTree::scene_lights() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND {
  // @@protoc_insertion_point(field_list:frame.proto.SceneTree.scene_lights)
  return _internal_scene_lights();
}
inline const ::google::protobuf::RepeatedPtrField<::frame::proto::SceneLight>&
SceneTree::_internal_scene_lights() const {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return _impl_.scene_lights_;
}
inline ::google::protobuf::RepeatedPtrField<::frame::proto::SceneLight>*
SceneTree::_internal_mutable_scene_lights() {
  PROTOBUF_TSAN_READ(&_impl_._tsan_detect_race);
  return &_impl_.scene_lights_;
}

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace proto
}  // namespace frame


namespace google {
namespace protobuf {

template <>
struct is_proto_enum<::frame::proto::SceneStaticMesh_RenderPrimitiveEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::SceneStaticMesh_RenderPrimitiveEnum>() {
  return ::frame::proto::SceneStaticMesh_RenderPrimitiveEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::SceneStaticMesh_MeshEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::SceneStaticMesh_MeshEnum>() {
  return ::frame::proto::SceneStaticMesh_MeshEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::SceneStaticMesh_RenderTimeEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::SceneStaticMesh_RenderTimeEnum>() {
  return ::frame::proto::SceneStaticMesh_RenderTimeEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::SceneStaticMesh_ShadowEffectEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::SceneStaticMesh_ShadowEffectEnum>() {
  return ::frame::proto::SceneStaticMesh_ShadowEffectEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::SceneLight_LightTypeEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::SceneLight_LightTypeEnum>() {
  return ::frame::proto::SceneLight_LightTypeEnum_descriptor();
}
template <>
struct is_proto_enum<::frame::proto::SceneLight_ShadowTypeEnum> : std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor<::frame::proto::SceneLight_ShadowTypeEnum>() {
  return ::frame::proto::SceneLight_ShadowTypeEnum_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_scene_2eproto_2epb_2eh
